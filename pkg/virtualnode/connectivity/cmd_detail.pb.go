// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cmd_detail.proto

package connectivity

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ImagePullPolicy int32

const (
	ImagePullAlways       ImagePullPolicy = 0
	ImagePullIfNotPresent ImagePullPolicy = 1
	ImagePullNever        ImagePullPolicy = 2
)

var ImagePullPolicy_name = map[int32]string{
	0: "ImagePullAlways",
	1: "ImagePullIfNotPresent",
	2: "ImagePullNever",
}

var ImagePullPolicy_value = map[string]int32{
	"ImagePullAlways":       0,
	"ImagePullIfNotPresent": 1,
	"ImagePullNever":        2,
}

func (ImagePullPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{0}
}

type RestartPolicy int32

const (
	RestartAlways    RestartPolicy = 0
	RestartOnFailure RestartPolicy = 1
	RestartNever     RestartPolicy = 2
)

var RestartPolicy_name = map[int32]string{
	0: "RestartAlways",
	1: "RestartOnFailure",
	2: "RestartNever",
}

var RestartPolicy_value = map[string]int32{
	"RestartAlways":    0,
	"RestartOnFailure": 1,
	"RestartNever":     2,
}

func (RestartPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{1}
}

type NodeCmd_Action int32

const (
	GetInfoAll    NodeCmd_Action = 0
	GetSystemInfo NodeCmd_Action = 1
	GetResources  NodeCmd_Action = 2
	GetConditions NodeCmd_Action = 3
)

var NodeCmd_Action_name = map[int32]string{
	0: "GetInfoAll",
	1: "GetSystemInfo",
	2: "GetResources",
	3: "GetConditions",
}

var NodeCmd_Action_value = map[string]int32{
	"GetInfoAll":    0,
	"GetSystemInfo": 1,
	"GetResources":  2,
	"GetConditions": 3,
}

func (NodeCmd_Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{0, 0}
}

type PodCmd_Action int32

const (
	// Create a new pod in device
	CreatePod PodCmd_Action = 0
	// Delete a existing pod in device
	DeletePod PodCmd_Action = 1
	// List all managed pod in device
	ListPods PodCmd_Action = 2
	// Execute commands in existing container
	Exec PodCmd_Action = 11
	// Attach to existing container
	Attach PodCmd_Action = 12
	// Get container/node log
	Log PodCmd_Action = 13
	// Port forward in pod
	PortForward PodCmd_Action = 14
	// user input or application data to
	// usually this action happens in Exec, Attach, PortForward session
	Input PodCmd_Action = 15
	// user tty resize
	// usually this action happens in Exec, Attach session when tty is enabled
	ResizeTty PodCmd_Action = 16
)

var PodCmd_Action_name = map[int32]string{
	0:  "CreatePod",
	1:  "DeletePod",
	2:  "ListPods",
	11: "Exec",
	12: "Attach",
	13: "Log",
	14: "PortForward",
	15: "Input",
	16: "ResizeTty",
}

var PodCmd_Action_value = map[string]int32{
	"CreatePod":   0,
	"DeletePod":   1,
	"ListPods":    2,
	"Exec":        11,
	"Attach":      12,
	"Log":         13,
	"PortForward": 14,
	"Input":       15,
	"ResizeTty":   16,
}

func (PodCmd_Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{1, 0}
}

type SecurityOptions_ProcMountKind int32

const (
	ProcMountDefault  SecurityOptions_ProcMountKind = 0
	ProcMountUnmasked SecurityOptions_ProcMountKind = 1
)

var SecurityOptions_ProcMountKind_name = map[int32]string{
	0: "ProcMountDefault",
	1: "ProcMountUnmasked",
}

var SecurityOptions_ProcMountKind_value = map[string]int32{
	"ProcMountDefault":  0,
	"ProcMountUnmasked": 1,
}

func (SecurityOptions_ProcMountKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{5, 0}
}

type NodeCmd struct {
	Action NodeCmd_Action `protobuf:"varint,1,opt,name=action,proto3,enum=connectivity.NodeCmd_Action" json:"action,omitempty"`
}

func (m *NodeCmd) Reset()      { *m = NodeCmd{} }
func (*NodeCmd) ProtoMessage() {}
func (*NodeCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{0}
}
func (m *NodeCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeCmd.Merge(m, src)
}
func (m *NodeCmd) XXX_Size() int {
	return m.Size()
}
func (m *NodeCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeCmd.DiscardUnknown(m)
}

var xxx_messageInfo_NodeCmd proto.InternalMessageInfo

func (m *NodeCmd) GetAction() NodeCmd_Action {
	if m != nil {
		return m.Action
	}
	return GetInfoAll
}

func (*NodeCmd) XXX_MessageName() string {
	return "connectivity.NodeCmd"
}

type PodCmd struct {
	// action type
	Action PodCmd_Action `protobuf:"varint,1,opt,name=action,proto3,enum=connectivity.PodCmd_Action" json:"action,omitempty"`
	// options for action
	//
	// Types that are valid to be assigned to Options:
	//	*PodCmd_CreateOptions
	//	*PodCmd_DeleteOptions
	//	*PodCmd_ListOptions
	//	*PodCmd_LogOptions
	//	*PodCmd_ExecOptions
	//	*PodCmd_PortForwardOptions
	//	*PodCmd_InputOptions
	//	*PodCmd_ResizeOptions
	Options isPodCmd_Options `protobuf_oneof:"options"`
}

func (m *PodCmd) Reset()      { *m = PodCmd{} }
func (*PodCmd) ProtoMessage() {}
func (*PodCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{1}
}
func (m *PodCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodCmd.Merge(m, src)
}
func (m *PodCmd) XXX_Size() int {
	return m.Size()
}
func (m *PodCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_PodCmd.DiscardUnknown(m)
}

var xxx_messageInfo_PodCmd proto.InternalMessageInfo

type isPodCmd_Options interface {
	isPodCmd_Options()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PodCmd_CreateOptions struct {
	CreateOptions *CreateOptions `protobuf:"bytes,11,opt,name=create_options,json=createOptions,proto3,oneof"`
}
type PodCmd_DeleteOptions struct {
	DeleteOptions *DeleteOptions `protobuf:"bytes,12,opt,name=delete_options,json=deleteOptions,proto3,oneof"`
}
type PodCmd_ListOptions struct {
	ListOptions *ListOptions `protobuf:"bytes,13,opt,name=list_options,json=listOptions,proto3,oneof"`
}
type PodCmd_LogOptions struct {
	LogOptions *LogOptions `protobuf:"bytes,14,opt,name=log_options,json=logOptions,proto3,oneof"`
}
type PodCmd_ExecOptions struct {
	ExecOptions *ExecOptions `protobuf:"bytes,15,opt,name=exec_options,json=execOptions,proto3,oneof"`
}
type PodCmd_PortForwardOptions struct {
	PortForwardOptions *PortForwardOptions `protobuf:"bytes,16,opt,name=port_forward_options,json=portForwardOptions,proto3,oneof"`
}
type PodCmd_InputOptions struct {
	InputOptions *InputOptions `protobuf:"bytes,17,opt,name=input_options,json=inputOptions,proto3,oneof"`
}
type PodCmd_ResizeOptions struct {
	ResizeOptions *TtyResizeOptions `protobuf:"bytes,18,opt,name=resize_options,json=resizeOptions,proto3,oneof"`
}

func (*PodCmd_CreateOptions) isPodCmd_Options()      {}
func (*PodCmd_DeleteOptions) isPodCmd_Options()      {}
func (*PodCmd_ListOptions) isPodCmd_Options()        {}
func (*PodCmd_LogOptions) isPodCmd_Options()         {}
func (*PodCmd_ExecOptions) isPodCmd_Options()        {}
func (*PodCmd_PortForwardOptions) isPodCmd_Options() {}
func (*PodCmd_InputOptions) isPodCmd_Options()       {}
func (*PodCmd_ResizeOptions) isPodCmd_Options()      {}

func (m *PodCmd) GetOptions() isPodCmd_Options {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *PodCmd) GetAction() PodCmd_Action {
	if m != nil {
		return m.Action
	}
	return CreatePod
}

func (m *PodCmd) GetCreateOptions() *CreateOptions {
	if x, ok := m.GetOptions().(*PodCmd_CreateOptions); ok {
		return x.CreateOptions
	}
	return nil
}

func (m *PodCmd) GetDeleteOptions() *DeleteOptions {
	if x, ok := m.GetOptions().(*PodCmd_DeleteOptions); ok {
		return x.DeleteOptions
	}
	return nil
}

func (m *PodCmd) GetListOptions() *ListOptions {
	if x, ok := m.GetOptions().(*PodCmd_ListOptions); ok {
		return x.ListOptions
	}
	return nil
}

func (m *PodCmd) GetLogOptions() *LogOptions {
	if x, ok := m.GetOptions().(*PodCmd_LogOptions); ok {
		return x.LogOptions
	}
	return nil
}

func (m *PodCmd) GetExecOptions() *ExecOptions {
	if x, ok := m.GetOptions().(*PodCmd_ExecOptions); ok {
		return x.ExecOptions
	}
	return nil
}

func (m *PodCmd) GetPortForwardOptions() *PortForwardOptions {
	if x, ok := m.GetOptions().(*PodCmd_PortForwardOptions); ok {
		return x.PortForwardOptions
	}
	return nil
}

func (m *PodCmd) GetInputOptions() *InputOptions {
	if x, ok := m.GetOptions().(*PodCmd_InputOptions); ok {
		return x.InputOptions
	}
	return nil
}

func (m *PodCmd) GetResizeOptions() *TtyResizeOptions {
	if x, ok := m.GetOptions().(*PodCmd_ResizeOptions); ok {
		return x.ResizeOptions
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PodCmd) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PodCmd_OneofMarshaler, _PodCmd_OneofUnmarshaler, _PodCmd_OneofSizer, []interface{}{
		(*PodCmd_CreateOptions)(nil),
		(*PodCmd_DeleteOptions)(nil),
		(*PodCmd_ListOptions)(nil),
		(*PodCmd_LogOptions)(nil),
		(*PodCmd_ExecOptions)(nil),
		(*PodCmd_PortForwardOptions)(nil),
		(*PodCmd_InputOptions)(nil),
		(*PodCmd_ResizeOptions)(nil),
	}
}

func _PodCmd_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PodCmd)
	// options
	switch x := m.Options.(type) {
	case *PodCmd_CreateOptions:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CreateOptions); err != nil {
			return err
		}
	case *PodCmd_DeleteOptions:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DeleteOptions); err != nil {
			return err
		}
	case *PodCmd_ListOptions:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ListOptions); err != nil {
			return err
		}
	case *PodCmd_LogOptions:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogOptions); err != nil {
			return err
		}
	case *PodCmd_ExecOptions:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExecOptions); err != nil {
			return err
		}
	case *PodCmd_PortForwardOptions:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PortForwardOptions); err != nil {
			return err
		}
	case *PodCmd_InputOptions:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InputOptions); err != nil {
			return err
		}
	case *PodCmd_ResizeOptions:
		_ = b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ResizeOptions); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PodCmd.Options has unexpected type %T", x)
	}
	return nil
}

func _PodCmd_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PodCmd)
	switch tag {
	case 11: // options.create_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CreateOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_CreateOptions{msg}
		return true, err
	case 12: // options.delete_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeleteOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_DeleteOptions{msg}
		return true, err
	case 13: // options.list_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ListOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_ListOptions{msg}
		return true, err
	case 14: // options.log_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_LogOptions{msg}
		return true, err
	case 15: // options.exec_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ExecOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_ExecOptions{msg}
		return true, err
	case 16: // options.port_forward_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PortForwardOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_PortForwardOptions{msg}
		return true, err
	case 17: // options.input_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InputOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_InputOptions{msg}
		return true, err
	case 18: // options.resize_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TtyResizeOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_ResizeOptions{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PodCmd_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PodCmd)
	// options
	switch x := m.Options.(type) {
	case *PodCmd_CreateOptions:
		s := proto.Size(x.CreateOptions)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodCmd_DeleteOptions:
		s := proto.Size(x.DeleteOptions)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodCmd_ListOptions:
		s := proto.Size(x.ListOptions)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodCmd_LogOptions:
		s := proto.Size(x.LogOptions)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodCmd_ExecOptions:
		s := proto.Size(x.ExecOptions)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodCmd_PortForwardOptions:
		s := proto.Size(x.PortForwardOptions)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodCmd_InputOptions:
		s := proto.Size(x.InputOptions)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodCmd_ResizeOptions:
		s := proto.Size(x.ResizeOptions)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func (*PodCmd) XXX_MessageName() string {
	return "connectivity.PodCmd"
}

type NamedData struct {
	DataMap map[string][]byte `protobuf:"bytes,1,rep,name=data_map,json=dataMap,proto3" json:"data_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NamedData) Reset()      { *m = NamedData{} }
func (*NamedData) ProtoMessage() {}
func (*NamedData) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{2}
}
func (m *NamedData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamedData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamedData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamedData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamedData.Merge(m, src)
}
func (m *NamedData) XXX_Size() int {
	return m.Size()
}
func (m *NamedData) XXX_DiscardUnknown() {
	xxx_messageInfo_NamedData.DiscardUnknown(m)
}

var xxx_messageInfo_NamedData proto.InternalMessageInfo

func (m *NamedData) GetDataMap() map[string][]byte {
	if m != nil {
		return m.DataMap
	}
	return nil
}

func (*NamedData) XXX_MessageName() string {
	return "connectivity.NamedData"
}

type ContainerPort struct {
	Protocol      string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	ContainerPort int32  `protobuf:"varint,2,opt,name=container_port,json=containerPort,proto3" json:"container_port,omitempty"`
	HostPort      int32  `protobuf:"varint,3,opt,name=host_port,json=hostPort,proto3" json:"host_port,omitempty"`
}

func (m *ContainerPort) Reset()      { *m = ContainerPort{} }
func (*ContainerPort) ProtoMessage() {}
func (*ContainerPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{3}
}
func (m *ContainerPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerPort.Merge(m, src)
}
func (m *ContainerPort) XXX_Size() int {
	return m.Size()
}
func (m *ContainerPort) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerPort.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerPort proto.InternalMessageInfo

func (m *ContainerPort) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *ContainerPort) GetContainerPort() int32 {
	if m != nil {
		return m.ContainerPort
	}
	return 0
}

func (m *ContainerPort) GetHostPort() int32 {
	if m != nil {
		return m.HostPort
	}
	return 0
}

func (*ContainerPort) XXX_MessageName() string {
	return "connectivity.ContainerPort"
}

type SELinuxOptions struct {
	Type  string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Level string `protobuf:"bytes,2,opt,name=level,proto3" json:"level,omitempty"`
	Role  string `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
	User  string `protobuf:"bytes,4,opt,name=user,proto3" json:"user,omitempty"`
}

func (m *SELinuxOptions) Reset()      { *m = SELinuxOptions{} }
func (*SELinuxOptions) ProtoMessage() {}
func (*SELinuxOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{4}
}
func (m *SELinuxOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SELinuxOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SELinuxOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SELinuxOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SELinuxOptions.Merge(m, src)
}
func (m *SELinuxOptions) XXX_Size() int {
	return m.Size()
}
func (m *SELinuxOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_SELinuxOptions.DiscardUnknown(m)
}

var xxx_messageInfo_SELinuxOptions proto.InternalMessageInfo

func (m *SELinuxOptions) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SELinuxOptions) GetLevel() string {
	if m != nil {
		return m.Level
	}
	return ""
}

func (m *SELinuxOptions) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *SELinuxOptions) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (*SELinuxOptions) XXX_MessageName() string {
	return "connectivity.SELinuxOptions"
}

type SecurityOptions struct {
	Privileged         bool                          `protobuf:"varint,1,opt,name=privileged,proto3" json:"privileged,omitempty"`
	AllowNewPrivileges bool                          `protobuf:"varint,2,opt,name=allow_new_privileges,json=allowNewPrivileges,proto3" json:"allow_new_privileges,omitempty"`
	NonRoot            bool                          `protobuf:"varint,3,opt,name=non_root,json=nonRoot,proto3" json:"non_root,omitempty"`
	ReadOnlyRootfs     bool                          `protobuf:"varint,4,opt,name=read_only_rootfs,json=readOnlyRootfs,proto3" json:"read_only_rootfs,omitempty"`
	User               int64                         `protobuf:"varint,5,opt,name=user,proto3" json:"user,omitempty"`
	Group              int64                         `protobuf:"varint,6,opt,name=group,proto3" json:"group,omitempty"`
	CapsAdd            []string                      `protobuf:"bytes,7,rep,name=caps_add,json=capsAdd,proto3" json:"caps_add,omitempty"`
	CapsDrop           []string                      `protobuf:"bytes,8,rep,name=caps_drop,json=capsDrop,proto3" json:"caps_drop,omitempty"`
	ProcMountKind      SecurityOptions_ProcMountKind `protobuf:"varint,9,opt,name=proc_mount_kind,json=procMountKind,proto3,enum=connectivity.SecurityOptions_ProcMountKind" json:"proc_mount_kind,omitempty"`
	SelinuxOptions     *SELinuxOptions               `protobuf:"bytes,10,opt,name=selinux_options,json=selinuxOptions,proto3" json:"selinux_options,omitempty"`
}

func (m *SecurityOptions) Reset()      { *m = SecurityOptions{} }
func (*SecurityOptions) ProtoMessage() {}
func (*SecurityOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{5}
}
func (m *SecurityOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecurityOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecurityOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecurityOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecurityOptions.Merge(m, src)
}
func (m *SecurityOptions) XXX_Size() int {
	return m.Size()
}
func (m *SecurityOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_SecurityOptions.DiscardUnknown(m)
}

var xxx_messageInfo_SecurityOptions proto.InternalMessageInfo

func (m *SecurityOptions) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *SecurityOptions) GetAllowNewPrivileges() bool {
	if m != nil {
		return m.AllowNewPrivileges
	}
	return false
}

func (m *SecurityOptions) GetNonRoot() bool {
	if m != nil {
		return m.NonRoot
	}
	return false
}

func (m *SecurityOptions) GetReadOnlyRootfs() bool {
	if m != nil {
		return m.ReadOnlyRootfs
	}
	return false
}

func (m *SecurityOptions) GetUser() int64 {
	if m != nil {
		return m.User
	}
	return 0
}

func (m *SecurityOptions) GetGroup() int64 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *SecurityOptions) GetCapsAdd() []string {
	if m != nil {
		return m.CapsAdd
	}
	return nil
}

func (m *SecurityOptions) GetCapsDrop() []string {
	if m != nil {
		return m.CapsDrop
	}
	return nil
}

func (m *SecurityOptions) GetProcMountKind() SecurityOptions_ProcMountKind {
	if m != nil {
		return m.ProcMountKind
	}
	return ProcMountDefault
}

func (m *SecurityOptions) GetSelinuxOptions() *SELinuxOptions {
	if m != nil {
		return m.SelinuxOptions
	}
	return nil
}

func (*SecurityOptions) XXX_MessageName() string {
	return "connectivity.SecurityOptions"
}

type MountOptions struct {
	MountPath string `protobuf:"bytes,1,opt,name=mount_path,json=mountPath,proto3" json:"mount_path,omitempty"`
	SubPath   string `protobuf:"bytes,2,opt,name=sub_path,json=subPath,proto3" json:"sub_path,omitempty"`
	ReadOnly  bool   `protobuf:"varint,3,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	// device type
	Type    string   `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	Options []string `protobuf:"bytes,5,rep,name=options,proto3" json:"options,omitempty"`
}

func (m *MountOptions) Reset()      { *m = MountOptions{} }
func (*MountOptions) ProtoMessage() {}
func (*MountOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{6}
}
func (m *MountOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MountOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MountOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MountOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MountOptions.Merge(m, src)
}
func (m *MountOptions) XXX_Size() int {
	return m.Size()
}
func (m *MountOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_MountOptions.DiscardUnknown(m)
}

var xxx_messageInfo_MountOptions proto.InternalMessageInfo

func (m *MountOptions) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *MountOptions) GetSubPath() string {
	if m != nil {
		return m.SubPath
	}
	return ""
}

func (m *MountOptions) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *MountOptions) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MountOptions) GetOptions() []string {
	if m != nil {
		return m.Options
	}
	return nil
}

func (*MountOptions) XXX_MessageName() string {
	return "connectivity.MountOptions"
}

type ContainerSpec struct {
	// container image name to pull
	Image           string          `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	ImagePullPolicy ImagePullPolicy `protobuf:"varint,2,opt,name=image_pull_policy,json=imagePullPolicy,proto3,enum=connectivity.ImagePullPolicy" json:"image_pull_policy,omitempty"`
	// Command (ENTRYPOINT in Dockerfile)
	Command []string `protobuf:"bytes,3,rep,name=command,proto3" json:"command,omitempty"`
	// Args (CMD in Dockerfile)
	Args       []string `protobuf:"bytes,4,rep,name=args,proto3" json:"args,omitempty"`
	WorkingDir string   `protobuf:"bytes,5,opt,name=working_dir,json=workingDir,proto3" json:"working_dir,omitempty"`
	Stdin      bool     `protobuf:"varint,6,opt,name=stdin,proto3" json:"stdin,omitempty"`
	StdinOnce  bool     `protobuf:"varint,7,opt,name=stdin_once,json=stdinOnce,proto3" json:"stdin_once,omitempty"`
	Tty        bool     `protobuf:"varint,8,opt,name=tty,proto3" json:"tty,omitempty"`
	// Contaienr environment variables
	//
	// key: env key
	// value: env value
	Envs map[string]string `protobuf:"bytes,11,rep,name=envs,proto3" json:"envs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Container voulme or device mounts
	//
	// key: volume or device name
	// value: mount options
	Mounts map[string]*MountOptions `protobuf:"bytes,12,rep,name=mounts,proto3" json:"mounts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	//
	// resolved security opts in pod
	//
	Security *SecurityOptions `protobuf:"bytes,21,opt,name=security,proto3" json:"security,omitempty"`
}

func (m *ContainerSpec) Reset()      { *m = ContainerSpec{} }
func (*ContainerSpec) ProtoMessage() {}
func (*ContainerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{7}
}
func (m *ContainerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerSpec.Merge(m, src)
}
func (m *ContainerSpec) XXX_Size() int {
	return m.Size()
}
func (m *ContainerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerSpec proto.InternalMessageInfo

func (m *ContainerSpec) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ContainerSpec) GetImagePullPolicy() ImagePullPolicy {
	if m != nil {
		return m.ImagePullPolicy
	}
	return ImagePullAlways
}

func (m *ContainerSpec) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ContainerSpec) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *ContainerSpec) GetWorkingDir() string {
	if m != nil {
		return m.WorkingDir
	}
	return ""
}

func (m *ContainerSpec) GetStdin() bool {
	if m != nil {
		return m.Stdin
	}
	return false
}

func (m *ContainerSpec) GetStdinOnce() bool {
	if m != nil {
		return m.StdinOnce
	}
	return false
}

func (m *ContainerSpec) GetTty() bool {
	if m != nil {
		return m.Tty
	}
	return false
}

func (m *ContainerSpec) GetEnvs() map[string]string {
	if m != nil {
		return m.Envs
	}
	return nil
}

func (m *ContainerSpec) GetMounts() map[string]*MountOptions {
	if m != nil {
		return m.Mounts
	}
	return nil
}

func (m *ContainerSpec) GetSecurity() *SecurityOptions {
	if m != nil {
		return m.Security
	}
	return nil
}

func (*ContainerSpec) XXX_MessageName() string {
	return "connectivity.ContainerSpec"
}

// replacement for cri/runtime/v1alpah2/.AuthConfig
type AuthConfig struct {
	Username      string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password      string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	Auth          string `protobuf:"bytes,3,opt,name=auth,proto3" json:"auth,omitempty"`
	ServerAddress string `protobuf:"bytes,4,opt,name=server_address,json=serverAddress,proto3" json:"server_address,omitempty"`
	// IdentityToken is used to authenticate the user and get
	// an access token for the registry.
	IdentityToken string `protobuf:"bytes,5,opt,name=identity_token,json=identityToken,proto3" json:"identity_token,omitempty"`
	// RegistryToken is a bearer token to be sent to a registry
	RegistryToken string `protobuf:"bytes,6,opt,name=registry_token,json=registryToken,proto3" json:"registry_token,omitempty"`
}

func (m *AuthConfig) Reset()      { *m = AuthConfig{} }
func (*AuthConfig) ProtoMessage() {}
func (*AuthConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{8}
}
func (m *AuthConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthConfig.Merge(m, src)
}
func (m *AuthConfig) XXX_Size() int {
	return m.Size()
}
func (m *AuthConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthConfig.DiscardUnknown(m)
}

var xxx_messageInfo_AuthConfig proto.InternalMessageInfo

func (m *AuthConfig) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *AuthConfig) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *AuthConfig) GetAuth() string {
	if m != nil {
		return m.Auth
	}
	return ""
}

func (m *AuthConfig) GetServerAddress() string {
	if m != nil {
		return m.ServerAddress
	}
	return ""
}

func (m *AuthConfig) GetIdentityToken() string {
	if m != nil {
		return m.IdentityToken
	}
	return ""
}

func (m *AuthConfig) GetRegistryToken() string {
	if m != nil {
		return m.RegistryToken
	}
	return ""
}

func (*AuthConfig) XXX_MessageName() string {
	return "connectivity.AuthConfig"
}

type CreateOptions struct {
	// kubernetes metadata
	PodUid        string        `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	Namespace     string        `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Name          string        `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	RestartPolicy RestartPolicy `protobuf:"varint,4,opt,name=restart_policy,json=restartPolicy,proto3,enum=connectivity.RestartPolicy" json:"restart_policy,omitempty"`
	//
	// Relationships to host environment
	//
	HostIpc     bool   `protobuf:"varint,5,opt,name=host_ipc,json=hostIpc,proto3" json:"host_ipc,omitempty"`
	HostNetwork bool   `protobuf:"varint,6,opt,name=host_network,json=hostNetwork,proto3" json:"host_network,omitempty"`
	HostPid     bool   `protobuf:"varint,7,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty"`
	Hostname    string `protobuf:"bytes,8,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// key: container name in the pod
	// value: container creation spec
	Containers map[string]*ContainerSpec `protobuf:"bytes,11,rep,name=containers,proto3" json:"containers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// key: image name
	// value: auth config
	// used to pull private images
	ImagePullAuthConfig map[string]*AuthConfig `protobuf:"bytes,12,rep,name=image_pull_auth_config,json=imagePullAuthConfig,proto3" json:"image_pull_auth_config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Container ports is processed when creating the pause container
	//
	// key: port name
	//          the port name is in the format of `{container}/{port_name}`
	//          if the port name is missing in the corev1.Container,
	//          it's index number in the will be used as port_name
	// value: port map and spec
	//          currently only ports with `host_port` specified will be exposed
	Ports map[string]*ContainerPort `protobuf:"bytes,13,rep,name=ports,proto3" json:"ports,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Volumes and devices' host path
	//
	// key: volume or device name
	// value: host path
	HostPaths map[string]string `protobuf:"bytes,21,rep,name=host_paths,json=hostPaths,proto3" json:"host_paths,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Data to populate files in container
	//
	// key: volume name
	// value: data from {ConfigMap, Secret}
	VolumeData map[string]*NamedData `protobuf:"bytes,22,rep,name=volume_data,json=volumeData,proto3" json:"volume_data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CreateOptions) Reset()      { *m = CreateOptions{} }
func (*CreateOptions) ProtoMessage() {}
func (*CreateOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{9}
}
func (m *CreateOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateOptions.Merge(m, src)
}
func (m *CreateOptions) XXX_Size() int {
	return m.Size()
}
func (m *CreateOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateOptions.DiscardUnknown(m)
}

var xxx_messageInfo_CreateOptions proto.InternalMessageInfo

func (m *CreateOptions) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *CreateOptions) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CreateOptions) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateOptions) GetRestartPolicy() RestartPolicy {
	if m != nil {
		return m.RestartPolicy
	}
	return RestartAlways
}

func (m *CreateOptions) GetHostIpc() bool {
	if m != nil {
		return m.HostIpc
	}
	return false
}

func (m *CreateOptions) GetHostNetwork() bool {
	if m != nil {
		return m.HostNetwork
	}
	return false
}

func (m *CreateOptions) GetHostPid() bool {
	if m != nil {
		return m.HostPid
	}
	return false
}

func (m *CreateOptions) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *CreateOptions) GetContainers() map[string]*ContainerSpec {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *CreateOptions) GetImagePullAuthConfig() map[string]*AuthConfig {
	if m != nil {
		return m.ImagePullAuthConfig
	}
	return nil
}

func (m *CreateOptions) GetPorts() map[string]*ContainerPort {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *CreateOptions) GetHostPaths() map[string]string {
	if m != nil {
		return m.HostPaths
	}
	return nil
}

func (m *CreateOptions) GetVolumeData() map[string]*NamedData {
	if m != nil {
		return m.VolumeData
	}
	return nil
}

func (*CreateOptions) XXX_MessageName() string {
	return "connectivity.CreateOptions"
}

type DeleteOptions struct {
	// pods to delete
	PodUid    string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	GraceTime int64  `protobuf:"varint,10,opt,name=grace_time,json=graceTime,proto3" json:"grace_time,omitempty"`
}

func (m *DeleteOptions) Reset()      { *m = DeleteOptions{} }
func (*DeleteOptions) ProtoMessage() {}
func (*DeleteOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{10}
}
func (m *DeleteOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteOptions.Merge(m, src)
}
func (m *DeleteOptions) XXX_Size() int {
	return m.Size()
}
func (m *DeleteOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteOptions.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteOptions proto.InternalMessageInfo

func (m *DeleteOptions) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *DeleteOptions) GetGraceTime() int64 {
	if m != nil {
		return m.GraceTime
	}
	return 0
}

func (*DeleteOptions) XXX_MessageName() string {
	return "connectivity.DeleteOptions"
}

type ListOptions struct {
	// pod namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// pod name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// show all pods available
	All bool `protobuf:"varint,3,opt,name=all,proto3" json:"all,omitempty"`
}

func (m *ListOptions) Reset()      { *m = ListOptions{} }
func (*ListOptions) ProtoMessage() {}
func (*ListOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{11}
}
func (m *ListOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListOptions.Merge(m, src)
}
func (m *ListOptions) XXX_Size() int {
	return m.Size()
}
func (m *ListOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ListOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ListOptions proto.InternalMessageInfo

func (m *ListOptions) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ListOptions) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListOptions) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (*ListOptions) XXX_MessageName() string {
	return "connectivity.ListOptions"
}

type LogOptions struct {
	PodUid     string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	Container  string `protobuf:"bytes,2,opt,name=container,proto3" json:"container,omitempty"`
	Follow     bool   `protobuf:"varint,3,opt,name=follow,proto3" json:"follow,omitempty"`
	Timestamp  bool   `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Since      int64  `protobuf:"varint,5,opt,name=since,proto3" json:"since,omitempty"`
	TailLines  int64  `protobuf:"varint,6,opt,name=tail_lines,json=tailLines,proto3" json:"tail_lines,omitempty"`
	BytesLimit int64  `protobuf:"varint,7,opt,name=bytes_limit,json=bytesLimit,proto3" json:"bytes_limit,omitempty"`
}

func (m *LogOptions) Reset()      { *m = LogOptions{} }
func (*LogOptions) ProtoMessage() {}
func (*LogOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{12}
}
func (m *LogOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogOptions.Merge(m, src)
}
func (m *LogOptions) XXX_Size() int {
	return m.Size()
}
func (m *LogOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_LogOptions.DiscardUnknown(m)
}

var xxx_messageInfo_LogOptions proto.InternalMessageInfo

func (m *LogOptions) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *LogOptions) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *LogOptions) GetFollow() bool {
	if m != nil {
		return m.Follow
	}
	return false
}

func (m *LogOptions) GetTimestamp() bool {
	if m != nil {
		return m.Timestamp
	}
	return false
}

func (m *LogOptions) GetSince() int64 {
	if m != nil {
		return m.Since
	}
	return 0
}

func (m *LogOptions) GetTailLines() int64 {
	if m != nil {
		return m.TailLines
	}
	return 0
}

func (m *LogOptions) GetBytesLimit() int64 {
	if m != nil {
		return m.BytesLimit
	}
	return 0
}

func (*LogOptions) XXX_MessageName() string {
	return "connectivity.LogOptions"
}

type ExecOptions struct {
	PodUid    string   `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	Container string   `protobuf:"bytes,2,opt,name=container,proto3" json:"container,omitempty"`
	Command   []string `protobuf:"bytes,3,rep,name=command,proto3" json:"command,omitempty"`
	Stdin     bool     `protobuf:"varint,4,opt,name=stdin,proto3" json:"stdin,omitempty"`
	Stdout    bool     `protobuf:"varint,5,opt,name=stdout,proto3" json:"stdout,omitempty"`
	Stderr    bool     `protobuf:"varint,6,opt,name=stderr,proto3" json:"stderr,omitempty"`
	Tty       bool     `protobuf:"varint,7,opt,name=tty,proto3" json:"tty,omitempty"`
}

func (m *ExecOptions) Reset()      { *m = ExecOptions{} }
func (*ExecOptions) ProtoMessage() {}
func (*ExecOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{13}
}
func (m *ExecOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecOptions.Merge(m, src)
}
func (m *ExecOptions) XXX_Size() int {
	return m.Size()
}
func (m *ExecOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ExecOptions proto.InternalMessageInfo

func (m *ExecOptions) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *ExecOptions) GetContainer() string {
	if m != nil {
		return m.Container
	}
	return ""
}

func (m *ExecOptions) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ExecOptions) GetStdin() bool {
	if m != nil {
		return m.Stdin
	}
	return false
}

func (m *ExecOptions) GetStdout() bool {
	if m != nil {
		return m.Stdout
	}
	return false
}

func (m *ExecOptions) GetStderr() bool {
	if m != nil {
		return m.Stderr
	}
	return false
}

func (m *ExecOptions) GetTty() bool {
	if m != nil {
		return m.Tty
	}
	return false
}

func (*ExecOptions) XXX_MessageName() string {
	return "connectivity.ExecOptions"
}

type PortForwardOptions struct {
	PodUid   string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	Port     int32  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	Protocol string `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
}

func (m *PortForwardOptions) Reset()      { *m = PortForwardOptions{} }
func (*PortForwardOptions) ProtoMessage() {}
func (*PortForwardOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{14}
}
func (m *PortForwardOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortForwardOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortForwardOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortForwardOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortForwardOptions.Merge(m, src)
}
func (m *PortForwardOptions) XXX_Size() int {
	return m.Size()
}
func (m *PortForwardOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_PortForwardOptions.DiscardUnknown(m)
}

var xxx_messageInfo_PortForwardOptions proto.InternalMessageInfo

func (m *PortForwardOptions) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *PortForwardOptions) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *PortForwardOptions) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (*PortForwardOptions) XXX_MessageName() string {
	return "connectivity.PortForwardOptions"
}

type InputOptions struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *InputOptions) Reset()      { *m = InputOptions{} }
func (*InputOptions) ProtoMessage() {}
func (*InputOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{15}
}
func (m *InputOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputOptions.Merge(m, src)
}
func (m *InputOptions) XXX_Size() int {
	return m.Size()
}
func (m *InputOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_InputOptions.DiscardUnknown(m)
}

var xxx_messageInfo_InputOptions proto.InternalMessageInfo

func (m *InputOptions) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (*InputOptions) XXX_MessageName() string {
	return "connectivity.InputOptions"
}

type TtyResizeOptions struct {
	Cols uint32 `protobuf:"varint,1,opt,name=cols,proto3" json:"cols,omitempty"`
	Rows uint32 `protobuf:"varint,2,opt,name=rows,proto3" json:"rows,omitempty"`
}

func (m *TtyResizeOptions) Reset()      { *m = TtyResizeOptions{} }
func (*TtyResizeOptions) ProtoMessage() {}
func (*TtyResizeOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{16}
}
func (m *TtyResizeOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TtyResizeOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TtyResizeOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TtyResizeOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TtyResizeOptions.Merge(m, src)
}
func (m *TtyResizeOptions) XXX_Size() int {
	return m.Size()
}
func (m *TtyResizeOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_TtyResizeOptions.DiscardUnknown(m)
}

var xxx_messageInfo_TtyResizeOptions proto.InternalMessageInfo

func (m *TtyResizeOptions) GetCols() uint32 {
	if m != nil {
		return m.Cols
	}
	return 0
}

func (m *TtyResizeOptions) GetRows() uint32 {
	if m != nil {
		return m.Rows
	}
	return 0
}

func (*TtyResizeOptions) XXX_MessageName() string {
	return "connectivity.TtyResizeOptions"
}
func init() {
	proto.RegisterEnum("connectivity.ImagePullPolicy", ImagePullPolicy_name, ImagePullPolicy_value)
	proto.RegisterEnum("connectivity.RestartPolicy", RestartPolicy_name, RestartPolicy_value)
	proto.RegisterEnum("connectivity.NodeCmd_Action", NodeCmd_Action_name, NodeCmd_Action_value)
	proto.RegisterEnum("connectivity.PodCmd_Action", PodCmd_Action_name, PodCmd_Action_value)
	proto.RegisterEnum("connectivity.SecurityOptions_ProcMountKind", SecurityOptions_ProcMountKind_name, SecurityOptions_ProcMountKind_value)
	proto.RegisterType((*NodeCmd)(nil), "connectivity.NodeCmd")
	proto.RegisterType((*PodCmd)(nil), "connectivity.PodCmd")
	proto.RegisterType((*NamedData)(nil), "connectivity.NamedData")
	proto.RegisterMapType((map[string][]byte)(nil), "connectivity.NamedData.DataMapEntry")
	proto.RegisterType((*ContainerPort)(nil), "connectivity.ContainerPort")
	proto.RegisterType((*SELinuxOptions)(nil), "connectivity.SELinuxOptions")
	proto.RegisterType((*SecurityOptions)(nil), "connectivity.SecurityOptions")
	proto.RegisterType((*MountOptions)(nil), "connectivity.MountOptions")
	proto.RegisterType((*ContainerSpec)(nil), "connectivity.ContainerSpec")
	proto.RegisterMapType((map[string]string)(nil), "connectivity.ContainerSpec.EnvsEntry")
	proto.RegisterMapType((map[string]*MountOptions)(nil), "connectivity.ContainerSpec.MountsEntry")
	proto.RegisterType((*AuthConfig)(nil), "connectivity.AuthConfig")
	proto.RegisterType((*CreateOptions)(nil), "connectivity.CreateOptions")
	proto.RegisterMapType((map[string]*ContainerSpec)(nil), "connectivity.CreateOptions.ContainersEntry")
	proto.RegisterMapType((map[string]string)(nil), "connectivity.CreateOptions.HostPathsEntry")
	proto.RegisterMapType((map[string]*AuthConfig)(nil), "connectivity.CreateOptions.ImagePullAuthConfigEntry")
	proto.RegisterMapType((map[string]*ContainerPort)(nil), "connectivity.CreateOptions.PortsEntry")
	proto.RegisterMapType((map[string]*NamedData)(nil), "connectivity.CreateOptions.VolumeDataEntry")
	proto.RegisterType((*DeleteOptions)(nil), "connectivity.DeleteOptions")
	proto.RegisterType((*ListOptions)(nil), "connectivity.ListOptions")
	proto.RegisterType((*LogOptions)(nil), "connectivity.LogOptions")
	proto.RegisterType((*ExecOptions)(nil), "connectivity.ExecOptions")
	proto.RegisterType((*PortForwardOptions)(nil), "connectivity.PortForwardOptions")
	proto.RegisterType((*InputOptions)(nil), "connectivity.InputOptions")
	proto.RegisterType((*TtyResizeOptions)(nil), "connectivity.TtyResizeOptions")
}

func init() { proto.RegisterFile("cmd_detail.proto", fileDescriptor_1571bcd24e248579) }

var fileDescriptor_1571bcd24e248579 = []byte{
	// 1977 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0x4f, 0x6f, 0xdc, 0xc6,
	0x15, 0x5f, 0x7a, 0xa5, 0xfd, 0xf3, 0xf6, 0x1f, 0x35, 0x91, 0x9d, 0xb5, 0x1c, 0x6f, 0xd5, 0x45,
	0xd3, 0x0a, 0x0e, 0xa2, 0xa4, 0x4e, 0x80, 0x26, 0xae, 0xd1, 0x40, 0x96, 0x14, 0x45, 0x8d, 0x22,
	0x6f, 0x29, 0x39, 0x87, 0x02, 0x05, 0x4b, 0x91, 0xa3, 0xd5, 0x40, 0x5c, 0x0e, 0x41, 0x0e, 0x57,
	0xde, 0x1e, 0x8a, 0x1e, 0x7b, 0x6c, 0xd1, 0x2f, 0xd1, 0x4f, 0xd0, 0xcf, 0x90, 0x8b, 0x51, 0x1f,
	0x73, 0xac, 0xe5, 0x1e, 0x7a, 0x0c, 0xd0, 0x2f, 0x50, 0xbc, 0x37, 0x24, 0x97, 0x5c, 0x4b, 0x0a,
	0x9a, 0xcb, 0x62, 0xde, 0x8f, 0xef, 0xbd, 0x79, 0xf3, 0xfe, 0xcd, 0x9b, 0x05, 0xd3, 0x9d, 0x78,
	0xb6, 0xc7, 0x95, 0x23, 0xfc, 0xcd, 0x30, 0x92, 0x4a, 0xb2, 0xb6, 0x2b, 0x83, 0x80, 0xbb, 0x4a,
	0x4c, 0x85, 0x9a, 0xad, 0xbd, 0x3f, 0x16, 0xea, 0x2c, 0x39, 0xd9, 0x74, 0xe5, 0xe4, 0x83, 0xb1,
	0x1c, 0xcb, 0x0f, 0x88, 0xe9, 0x24, 0x39, 0x25, 0x8a, 0x08, 0x5a, 0x69, 0xe1, 0xe1, 0x5f, 0x0d,
	0xa8, 0x1f, 0x4a, 0x8f, 0x6f, 0x4f, 0x3c, 0xf6, 0x31, 0xd4, 0x1c, 0x57, 0x09, 0x19, 0xf4, 0x8d,
	0x75, 0x63, 0xa3, 0xfb, 0xf0, 0x9d, 0xcd, 0xa2, 0xe6, 0xcd, 0x94, 0x6d, 0x73, 0x8b, 0x78, 0xac,
	0x94, 0x77, 0x38, 0x82, 0x9a, 0x46, 0x58, 0x17, 0x60, 0x8f, 0xab, 0xfd, 0xe0, 0x54, 0x6e, 0xf9,
	0xbe, 0x59, 0x61, 0x2b, 0xd0, 0xd9, 0xe3, 0xea, 0x68, 0x16, 0x2b, 0x3e, 0x41, 0xd4, 0x34, 0x98,
	0x09, 0xed, 0x3d, 0xae, 0x2c, 0x1e, 0xcb, 0x24, 0x72, 0x79, 0x6c, 0xde, 0x4a, 0x99, 0xb6, 0x65,
	0xe0, 0x09, 0x54, 0x12, 0x9b, 0xd5, 0xe1, 0x7f, 0x97, 0xa1, 0x36, 0x92, 0x1e, 0x9a, 0xf4, 0xd1,
	0x82, 0x49, 0xf7, 0xca, 0x26, 0x69, 0xae, 0x05, 0x8b, 0xd8, 0x0e, 0x74, 0xdd, 0x88, 0x3b, 0x8a,
	0xdb, 0x32, 0x24, 0x9d, 0xfd, 0xd6, 0xba, 0xb1, 0xd1, 0x5a, 0x14, 0xde, 0x26, 0x9e, 0xa7, 0x9a,
	0xe5, 0x8b, 0x8a, 0xd5, 0x71, 0x8b, 0x00, 0x6a, 0xf1, 0xb8, 0xcf, 0x0b, 0x5a, 0xda, 0x57, 0x69,
	0xd9, 0x21, 0x9e, 0x82, 0x16, 0xaf, 0x08, 0xb0, 0x5f, 0x41, 0xdb, 0x17, 0xb1, 0xca, 0x75, 0x74,
	0x48, 0xc7, 0xdd, 0xb2, 0x8e, 0x03, 0x11, 0xab, 0xb9, 0x86, 0x96, 0x3f, 0x27, 0xd9, 0x2f, 0xa1,
	0xe5, 0xcb, 0x71, 0x2e, 0xde, 0x25, 0xf1, 0xfe, 0x82, 0xb8, 0x1c, 0xcf, 0xa5, 0xc1, 0xcf, 0x29,
	0xdc, 0x9c, 0x3f, 0xe7, 0x6e, 0x2e, 0xdd, 0xbb, 0x6a, 0xf3, 0xdd, 0xe7, 0xdc, 0x2d, 0x6c, 0xce,
	0xe7, 0x24, 0x3b, 0x86, 0xd5, 0x50, 0x46, 0xca, 0x3e, 0x95, 0xd1, 0x85, 0x13, 0x79, 0xb9, 0x1e,
	0x93, 0xf4, 0xac, 0x2f, 0xc6, 0x22, 0x52, 0x9f, 0x6b, 0xc6, 0xb9, 0x3a, 0x16, 0xbe, 0x81, 0xb2,
	0x2d, 0xe8, 0x88, 0x20, 0x4c, 0xe6, 0x3e, 0x59, 0x21, 0x75, 0x6b, 0x65, 0x75, 0xfb, 0xc8, 0x32,
	0x57, 0xd4, 0x16, 0x05, 0x9a, 0xed, 0x41, 0x37, 0xe2, 0xb1, 0xf8, 0xc3, 0x3c, 0x36, 0x8c, 0x74,
	0x0c, 0xca, 0x3a, 0x8e, 0xd5, 0xcc, 0x22, 0xb6, 0x42, 0x78, 0xa2, 0x22, 0x30, 0xfc, 0x63, 0x9e,
	0xbc, 0x1d, 0x68, 0xea, 0x84, 0x18, 0x49, 0xcf, 0xac, 0x20, 0xa9, 0x23, 0x8b, 0xa4, 0xc1, 0xda,
	0xd0, 0xc0, 0x20, 0x8d, 0xa4, 0x87, 0x39, 0xdb, 0x80, 0x25, 0xf4, 0x9a, 0xd9, 0x62, 0x00, 0xb5,
	0x2d, 0xa5, 0x1c, 0xf7, 0xcc, 0x6c, 0xb3, 0x3a, 0x54, 0x0f, 0xe4, 0xd8, 0xec, 0xb0, 0x1e, 0xb4,
	0x0a, 0xce, 0x30, 0xbb, 0xac, 0x09, 0xcb, 0x74, 0x1c, 0xb3, 0x87, 0x7a, 0xb5, 0x49, 0xc7, 0x6a,
	0x66, 0x9a, 0x4f, 0x9a, 0x50, 0x4f, 0x4f, 0x30, 0xfc, 0xb3, 0x01, 0xcd, 0x43, 0x67, 0xc2, 0xbd,
	0x1d, 0x47, 0x39, 0xec, 0x33, 0x68, 0x78, 0x8e, 0x72, 0xec, 0x89, 0x13, 0xf6, 0x8d, 0xf5, 0xea,
	0x46, 0xeb, 0xe1, 0x4f, 0x16, 0xaa, 0x31, 0x63, 0xdd, 0xc4, 0x9f, 0xaf, 0x9c, 0x70, 0x37, 0x50,
	0xd1, 0xcc, 0xaa, 0x7b, 0x9a, 0x5a, 0x7b, 0x04, 0xed, 0xe2, 0x07, 0x66, 0x42, 0xf5, 0x9c, 0xcf,
	0xa8, 0x8c, 0x9a, 0x16, 0x2e, 0xd9, 0x2a, 0x2c, 0x4f, 0x1d, 0x3f, 0xe1, 0xfd, 0x5b, 0xeb, 0xc6,
	0x46, 0xdb, 0xd2, 0xc4, 0xa3, 0x5b, 0x9f, 0x18, 0x43, 0x09, 0x9d, 0x6d, 0x19, 0x28, 0x47, 0x04,
	0x3c, 0xc2, 0x93, 0xb0, 0x35, 0x68, 0x50, 0xbb, 0x70, 0xa5, 0x9f, 0x6a, 0xc8, 0x69, 0xf6, 0x2e,
	0x74, 0xdd, 0x8c, 0xd9, 0xc6, 0x70, 0x93, 0xbe, 0x65, 0xab, 0xe3, 0x96, 0x54, 0xdc, 0x83, 0xe6,
	0x99, 0x8c, 0x95, 0xe6, 0xa8, 0x12, 0x47, 0x03, 0x01, 0xfc, 0x38, 0x3c, 0x81, 0xee, 0xd1, 0xee,
	0x81, 0x08, 0x92, 0xe7, 0x59, 0x84, 0x19, 0x2c, 0xa9, 0x59, 0xc8, 0xd3, 0xdd, 0x68, 0x8d, 0x06,
	0xfb, 0x7c, 0xca, 0x7d, 0xda, 0xa0, 0x69, 0x69, 0x02, 0x39, 0x23, 0xe9, 0x73, 0xd2, 0xd9, 0xb4,
	0x68, 0x8d, 0x58, 0x12, 0xf3, 0xa8, 0xbf, 0xa4, 0x31, 0x5c, 0x0f, 0xff, 0x5d, 0x85, 0xde, 0x11,
	0x77, 0x93, 0x48, 0xa8, 0x59, 0xb6, 0xcb, 0x00, 0x20, 0x8c, 0xc4, 0x54, 0xf8, 0x7c, 0xcc, 0x3d,
	0xda, 0xab, 0x61, 0x15, 0x10, 0xf6, 0x21, 0xac, 0x3a, 0xbe, 0x2f, 0x2f, 0xec, 0x80, 0x5f, 0xd8,
	0x39, 0x1e, 0x93, 0x01, 0x0d, 0x8b, 0xd1, 0xb7, 0x43, 0x7e, 0x31, 0xca, 0xbf, 0xb0, 0xbb, 0xd0,
	0x08, 0x64, 0x60, 0x47, 0x52, 0xea, 0x53, 0x36, 0xac, 0x7a, 0x20, 0x03, 0x4b, 0x4a, 0xc5, 0x36,
	0xc0, 0x8c, 0xb8, 0xe3, 0xd9, 0x32, 0xf0, 0x67, 0xc4, 0x70, 0x1a, 0x93, 0x81, 0x0d, 0xab, 0x8b,
	0xf8, 0xd3, 0xc0, 0x9f, 0x59, 0x84, 0xe6, 0xe6, 0x2f, 0xaf, 0x1b, 0x1b, 0x55, 0x6d, 0x3e, 0x1e,
	0x7e, 0x1c, 0xc9, 0x24, 0xec, 0xd7, 0x08, 0xd4, 0x04, 0x6e, 0xe7, 0x3a, 0x61, 0x6c, 0x3b, 0x9e,
	0xd7, 0xaf, 0xaf, 0x57, 0x37, 0x9a, 0x56, 0x1d, 0xe9, 0x2d, 0xcf, 0x43, 0x87, 0xd3, 0x27, 0x2f,
	0x92, 0x61, 0xbf, 0x41, 0xdf, 0x88, 0x77, 0x27, 0x92, 0x21, 0x3b, 0x82, 0x5e, 0x18, 0x49, 0xd7,
	0x9e, 0xc8, 0x24, 0x50, 0xf6, 0xb9, 0x08, 0xbc, 0x7e, 0x93, 0x1a, 0xec, 0x7b, 0xe5, 0x2c, 0x5b,
	0x70, 0xd8, 0xe6, 0x28, 0x92, 0xee, 0x57, 0x28, 0xf3, 0xa5, 0x08, 0x3c, 0xab, 0x13, 0x16, 0x49,
	0xb6, 0x0b, 0xbd, 0x98, 0xfb, 0x18, 0xc5, 0xbc, 0x2c, 0x81, 0xca, 0x72, 0xe1, 0x22, 0x29, 0x87,
	0xda, 0xea, 0xa6, 0x42, 0x59, 0x4d, 0x3e, 0x86, 0x4e, 0x69, 0x1b, 0xb6, 0x0a, 0x66, 0x0e, 0xec,
	0xf0, 0x53, 0x27, 0xf1, 0x95, 0x59, 0x61, 0xb7, 0x61, 0x25, 0x47, 0x9f, 0x05, 0x13, 0x27, 0x3e,
	0xe7, 0x9e, 0x69, 0x0c, 0xff, 0x66, 0x40, 0x9b, 0xb0, 0x2c, 0xc6, 0xf7, 0x01, 0xf4, 0x29, 0x43,
	0x47, 0x9d, 0xa5, 0xf9, 0xd4, 0x24, 0x64, 0xe4, 0xa8, 0x33, 0xf4, 0x60, 0x9c, 0x9c, 0xe8, 0x8f,
	0x3a, 0xaf, 0xea, 0x71, 0x72, 0x42, 0x9f, 0xee, 0x41, 0x33, 0x0f, 0x58, 0x1a, 0xcc, 0x46, 0x16,
	0xa9, 0x3c, 0x41, 0x97, 0x0a, 0x09, 0xda, 0xcf, 0xab, 0xb9, 0xbf, 0xac, 0x83, 0x91, 0x15, 0xf7,
	0x8b, 0xa5, 0x42, 0x49, 0x1d, 0x85, 0xdc, 0xc5, 0x78, 0x8a, 0x89, 0x33, 0xce, 0x32, 0x5c, 0x13,
	0x6c, 0x1f, 0x56, 0x68, 0x61, 0x87, 0x89, 0xef, 0xdb, 0xa1, 0xf4, 0x85, 0x3b, 0x23, 0xb3, 0xba,
	0x0f, 0xef, 0x2f, 0xf4, 0x47, 0x64, 0x1b, 0x25, 0xbe, 0x3f, 0x22, 0x26, 0xab, 0x27, 0xca, 0x00,
	0x1a, 0xe3, 0xca, 0xc9, 0xc4, 0x09, 0xbc, 0x7e, 0x35, 0xcd, 0x0c, 0x4d, 0xa2, 0xe9, 0x4e, 0x34,
	0xc6, 0xe4, 0x43, 0x98, 0xd6, 0xec, 0x47, 0xd0, 0xba, 0x90, 0xd1, 0xb9, 0x08, 0xc6, 0xb6, 0x27,
	0x74, 0xe6, 0x35, 0x2d, 0x48, 0xa1, 0x1d, 0x41, 0xf9, 0x17, 0x2b, 0x4f, 0x04, 0x94, 0x7f, 0x0d,
	0x4b, 0x13, 0xe8, 0x5c, 0x5a, 0xd8, 0x32, 0x70, 0x79, 0xbf, 0x4e, 0x9f, 0x9a, 0x84, 0x3c, 0x0d,
	0x5c, 0x8e, 0x4d, 0x47, 0xa9, 0x59, 0xbf, 0x41, 0x38, 0x2e, 0xd9, 0xa7, 0xb0, 0xc4, 0x83, 0x29,
	0xde, 0xc8, 0xd8, 0xd3, 0xde, 0x5d, 0xb8, 0x91, 0x8b, 0x1e, 0xda, 0xdc, 0x0d, 0xa6, 0xb1, 0x6e,
	0x6a, 0x24, 0xc2, 0x3e, 0x83, 0x1a, 0x85, 0x0d, 0x2f, 0x62, 0x14, 0xfe, 0xd9, 0x4d, 0xc2, 0x94,
	0x02, 0xa9, 0x78, 0x2a, 0xc6, 0x3e, 0x85, 0x46, 0x9c, 0xe6, 0x73, 0xff, 0x36, 0x25, 0xe6, 0xfd,
	0x1b, 0xb3, 0xdd, 0xca, 0xd9, 0xd7, 0x7e, 0x01, 0xcd, 0xdc, 0x9c, 0xef, 0x6b, 0xa5, 0xcd, 0x42,
	0x2b, 0x5d, 0x7b, 0x06, 0xad, 0x82, 0x29, 0x57, 0x88, 0x7e, 0x58, 0x14, 0x7d, 0xe3, 0x16, 0x2c,
	0x66, 0x72, 0xb1, 0x43, 0xbf, 0x30, 0x00, 0xb6, 0x12, 0x75, 0xb6, 0x2d, 0x83, 0x53, 0x31, 0xc6,
	0xfe, 0x8c, 0x4d, 0x22, 0x70, 0x26, 0x59, 0x3e, 0xe5, 0x34, 0xf5, 0x6e, 0x27, 0x8e, 0x2f, 0x64,
	0xe4, 0xa5, 0xe6, 0xe5, 0x34, 0x65, 0x42, 0xa2, 0xce, 0xb2, 0xde, 0x89, 0x6b, 0xec, 0xe7, 0x31,
	0x8f, 0xa6, 0x3c, 0xc2, 0xa6, 0x12, 0xf1, 0x38, 0x4e, 0x53, 0xbc, 0xa3, 0xd1, 0x2d, 0x0d, 0x22,
	0x9b, 0xf0, 0x78, 0xa0, 0x84, 0x9a, 0xd9, 0x4a, 0x9e, 0xf3, 0x20, 0xcd, 0x99, 0x4e, 0x86, 0x1e,
	0x23, 0x88, 0x6c, 0x11, 0x1f, 0x8b, 0x58, 0x45, 0x19, 0x5b, 0x4d, 0xb3, 0x65, 0x28, 0xb1, 0x0d,
	0x5f, 0x34, 0xa0, 0x53, 0x9a, 0xc7, 0xd8, 0xdb, 0x50, 0x0f, 0xa5, 0x67, 0x27, 0xc2, 0x4b, 0x4f,
	0x54, 0x0b, 0xa5, 0xf7, 0x4c, 0x78, 0xec, 0x1d, 0x68, 0xe2, 0xb9, 0xe2, 0xd0, 0x71, 0x33, 0x7f,
	0xcf, 0x01, 0x3c, 0x11, 0x79, 0x21, 0x3d, 0x11, 0x79, 0xe0, 0x09, 0x4d, 0x0b, 0xca, 0x89, 0x54,
	0x56, 0x51, 0x4b, 0x57, 0x0d, 0x93, 0x96, 0xe6, 0x49, 0xeb, 0xa9, 0x13, 0x15, 0x49, 0x6c, 0x13,
	0x74, 0x7d, 0x89, 0xd0, 0xa5, 0x83, 0x36, 0xac, 0x3a, 0xd2, 0xfb, 0xa1, 0xcb, 0x7e, 0x0c, 0x6d,
	0xfa, 0x14, 0x70, 0x85, 0xf5, 0x92, 0x16, 0x48, 0x0b, 0xb1, 0x43, 0x0d, 0xe5, 0xd2, 0xa1, 0xf0,
	0xd2, 0x22, 0x21, 0xe9, 0x91, 0xf0, 0x30, 0x3c, 0xb8, 0x24, 0xa3, 0x1b, 0x3a, 0x3c, 0x19, 0xcd,
	0xbe, 0x04, 0xc8, 0x2f, 0xd1, 0xac, 0x64, 0xde, 0xbb, 0x61, 0x88, 0x9d, 0xd7, 0x40, 0x9a, 0xf9,
	0x05, 0x71, 0x26, 0xe0, 0x4e, 0xa1, 0xb5, 0x60, 0xa8, 0x6d, 0x97, 0xb2, 0x27, 0x2d, 0xa7, 0x8f,
	0x6f, 0x52, 0x9c, 0x77, 0x9b, 0x79, 0xd2, 0xe9, 0x1d, 0xde, 0x12, 0x6f, 0x7e, 0x61, 0x8f, 0x61,
	0x19, 0xaf, 0x79, 0x9c, 0x76, 0x51, 0xf3, 0x4f, 0x6f, 0xd2, 0x8c, 0xf7, 0x7f, 0x6a, 0xad, 0x16,
	0x62, 0xfb, 0x00, 0xda, 0x59, 0x8e, 0x3a, 0x8b, 0xfb, 0xb7, 0x49, 0xc5, 0x83, 0x9b, 0x54, 0x7c,
	0x81, 0xae, 0x44, 0x66, 0xad, 0x86, 0xe6, 0x0c, 0xa2, 0xd9, 0x01, 0xb4, 0xa6, 0xd2, 0x4f, 0x26,
	0xdc, 0xc6, 0xb1, 0xa8, 0x7f, 0xe7, 0xfb, 0x3d, 0xf8, 0x35, 0xb1, 0xe3, 0xe4, 0x94, 0x7a, 0x70,
	0x9a, 0x03, 0x6b, 0xbf, 0x85, 0xde, 0x82, 0x83, 0xaf, 0xa8, 0xe7, 0x9f, 0x97, 0xeb, 0xf9, 0xde,
	0x0d, 0x4d, 0xaa, 0xd8, 0x27, 0x7e, 0x0f, 0xfd, 0xeb, 0x7c, 0x7c, 0xc5, 0x26, 0x9b, 0xe5, 0x4d,
	0x16, 0xde, 0x03, 0x73, 0xf9, 0x72, 0x27, 0x82, 0xb9, 0xaf, 0x7f, 0xb8, 0xe1, 0xa8, 0xa3, 0xa8,
	0xf6, 0x31, 0x74, 0xcb, 0xfe, 0xff, 0xbf, 0xda, 0xe3, 0xd7, 0xd0, 0x5b, 0xf0, 0xf8, 0x15, 0xe2,
	0xef, 0x97, 0x2d, 0x7b, 0xfb, 0x9a, 0x41, 0xb8, 0xd8, 0x1f, 0xf7, 0xa0, 0x53, 0x7a, 0x98, 0x5d,
	0xdf, 0x4e, 0xee, 0x03, 0x8c, 0x23, 0xc7, 0xe5, 0xb6, 0x12, 0x13, 0x4e, 0xf3, 0x4a, 0xd5, 0x6a,
	0x12, 0x72, 0x2c, 0x26, 0x7c, 0xf8, 0x1b, 0x68, 0x15, 0x5e, 0x67, 0xe5, 0xe6, 0x63, 0x5c, 0xd7,
	0x7c, 0x6e, 0x15, 0x9a, 0x8f, 0x09, 0x55, 0xc7, 0xf7, 0xd3, 0xf1, 0x01, 0x97, 0xc3, 0x7f, 0x1a,
	0x00, 0xf3, 0x27, 0xdb, 0x8d, 0x8d, 0x2e, 0x2f, 0xdf, 0xac, 0xd1, 0xe5, 0x00, 0xbb, 0x03, 0xb5,
	0x53, 0x89, 0xf3, 0x67, 0xaa, 0x3a, 0xa5, 0x50, 0x0a, 0x4f, 0x12, 0x2b, 0x67, 0x12, 0xa6, 0xe3,
	0xe5, 0x1c, 0xa0, 0x5b, 0x5c, 0xe0, 0x55, 0xad, 0x47, 0x4b, 0x4d, 0xa0, 0x0f, 0x94, 0x23, 0x7c,
	0xdb, 0x17, 0x01, 0x8f, 0xd3, 0x01, 0xb3, 0x89, 0xc8, 0x01, 0x02, 0x38, 0x1b, 0x9c, 0xcc, 0x14,
	0x8f, 0x6d, 0x5f, 0x4c, 0x84, 0xa2, 0x06, 0x56, 0xb5, 0x80, 0xa0, 0x03, 0x44, 0x86, 0xff, 0x30,
	0xa0, 0x55, 0x78, 0x46, 0xfe, 0xd0, 0x23, 0x5d, 0x3f, 0xb1, 0xe4, 0xc3, 0xc7, 0x52, 0x71, 0xf8,
	0xb8, 0x03, 0xb5, 0x58, 0x79, 0x32, 0x51, 0x69, 0x47, 0x4e, 0xa9, 0x14, 0xe7, 0x51, 0x94, 0xb6,
	0xe2, 0x94, 0xca, 0xa6, 0x91, 0x7a, 0x3e, 0x8d, 0x0c, 0x7f, 0x07, 0xec, 0xcd, 0x67, 0xeb, 0xf5,
	0xe6, 0x33, 0x58, 0x2a, 0x3c, 0x70, 0x68, 0x5d, 0x7a, 0x1a, 0x55, 0xcb, 0x4f, 0xa3, 0xe1, 0x10,
	0xda, 0xc5, 0x67, 0x2c, 0xca, 0x53, 0x1f, 0x32, 0xe8, 0xc1, 0x45, 0xeb, 0xe1, 0x23, 0x30, 0x17,
	0x9f, 0xa9, 0xc8, 0xe7, 0x4a, 0x3f, 0x26, 0xbe, 0x8e, 0x45, 0x6b, 0xfd, 0xcc, 0xb9, 0xd0, 0x4f,
	0x8f, 0x8e, 0x45, 0xeb, 0x07, 0xcf, 0xa0, 0xb7, 0x30, 0x06, 0xb2, 0xb7, 0x0a, 0xd0, 0x96, 0x7f,
	0xe1, 0xcc, 0x62, 0xb3, 0xc2, 0xee, 0xc2, 0xed, 0x1c, 0xdc, 0x3f, 0x3d, 0x94, 0x6a, 0x14, 0xf1,
	0x98, 0x07, 0xca, 0x34, 0x18, 0x83, 0x6e, 0xfe, 0xe9, 0x90, 0x4f, 0x79, 0x64, 0xde, 0x7a, 0xf0,
	0x6b, 0xe8, 0x94, 0xee, 0x42, 0xb6, 0x92, 0x03, 0xb9, 0xca, 0x55, 0x30, 0x53, 0xe8, 0x69, 0xf0,
	0xb9, 0x23, 0xfc, 0x24, 0xe2, 0xfa, 0xef, 0x9d, 0x14, 0x4d, 0x75, 0x3d, 0xf9, 0xe4, 0xe5, 0xab,
	0x41, 0xe5, 0xdb, 0x57, 0x83, 0xca, 0x77, 0xaf, 0x06, 0xc6, 0x9f, 0x2e, 0x07, 0xc6, 0xdf, 0x2f,
	0x07, 0xc6, 0x37, 0x97, 0x03, 0xe3, 0xe5, 0xe5, 0xc0, 0xf8, 0xd7, 0xe5, 0xc0, 0xf8, 0xcf, 0xe5,
	0xa0, 0xf2, 0xdd, 0xe5, 0xc0, 0xf8, 0xcb, 0xeb, 0x41, 0xe5, 0x9b, 0xd7, 0x03, 0xe3, 0xe5, 0xeb,
	0x41, 0xe5, 0xdb, 0xd7, 0x83, 0xca, 0x49, 0x8d, 0xdc, 0xf8, 0xd1, 0xff, 0x02, 0x00, 0x00, 0xff,
	0xff, 0xce, 0x36, 0xda, 0x0e, 0xf1, 0x12, 0x00, 0x00,
}

func (x ImagePullPolicy) String() string {
	s, ok := ImagePullPolicy_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x RestartPolicy) String() string {
	s, ok := RestartPolicy_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x NodeCmd_Action) String() string {
	s, ok := NodeCmd_Action_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PodCmd_Action) String() string {
	s, ok := PodCmd_Action_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SecurityOptions_ProcMountKind) String() string {
	s, ok := SecurityOptions_ProcMountKind_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *NodeCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeCmd)
	if !ok {
		that2, ok := that.(NodeCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	return true
}
func (this *PodCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd)
	if !ok {
		that2, ok := that.(PodCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if that1.Options == nil {
		if this.Options != nil {
			return false
		}
	} else if this.Options == nil {
		return false
	} else if !this.Options.Equal(that1.Options) {
		return false
	}
	return true
}
func (this *PodCmd_CreateOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_CreateOptions)
	if !ok {
		that2, ok := that.(PodCmd_CreateOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CreateOptions.Equal(that1.CreateOptions) {
		return false
	}
	return true
}
func (this *PodCmd_DeleteOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_DeleteOptions)
	if !ok {
		that2, ok := that.(PodCmd_DeleteOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeleteOptions.Equal(that1.DeleteOptions) {
		return false
	}
	return true
}
func (this *PodCmd_ListOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_ListOptions)
	if !ok {
		that2, ok := that.(PodCmd_ListOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ListOptions.Equal(that1.ListOptions) {
		return false
	}
	return true
}
func (this *PodCmd_LogOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_LogOptions)
	if !ok {
		that2, ok := that.(PodCmd_LogOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogOptions.Equal(that1.LogOptions) {
		return false
	}
	return true
}
func (this *PodCmd_ExecOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_ExecOptions)
	if !ok {
		that2, ok := that.(PodCmd_ExecOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExecOptions.Equal(that1.ExecOptions) {
		return false
	}
	return true
}
func (this *PodCmd_PortForwardOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_PortForwardOptions)
	if !ok {
		that2, ok := that.(PodCmd_PortForwardOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PortForwardOptions.Equal(that1.PortForwardOptions) {
		return false
	}
	return true
}
func (this *PodCmd_InputOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_InputOptions)
	if !ok {
		that2, ok := that.(PodCmd_InputOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InputOptions.Equal(that1.InputOptions) {
		return false
	}
	return true
}
func (this *PodCmd_ResizeOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_ResizeOptions)
	if !ok {
		that2, ok := that.(PodCmd_ResizeOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ResizeOptions.Equal(that1.ResizeOptions) {
		return false
	}
	return true
}
func (this *NamedData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamedData)
	if !ok {
		that2, ok := that.(NamedData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.DataMap) != len(that1.DataMap) {
		return false
	}
	for i := range this.DataMap {
		if !bytes.Equal(this.DataMap[i], that1.DataMap[i]) {
			return false
		}
	}
	return true
}
func (this *ContainerPort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerPort)
	if !ok {
		that2, ok := that.(ContainerPort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.ContainerPort != that1.ContainerPort {
		return false
	}
	if this.HostPort != that1.HostPort {
		return false
	}
	return true
}
func (this *SELinuxOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SELinuxOptions)
	if !ok {
		that2, ok := that.(SELinuxOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Level != that1.Level {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	if this.User != that1.User {
		return false
	}
	return true
}
func (this *SecurityOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecurityOptions)
	if !ok {
		that2, ok := that.(SecurityOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Privileged != that1.Privileged {
		return false
	}
	if this.AllowNewPrivileges != that1.AllowNewPrivileges {
		return false
	}
	if this.NonRoot != that1.NonRoot {
		return false
	}
	if this.ReadOnlyRootfs != that1.ReadOnlyRootfs {
		return false
	}
	if this.User != that1.User {
		return false
	}
	if this.Group != that1.Group {
		return false
	}
	if len(this.CapsAdd) != len(that1.CapsAdd) {
		return false
	}
	for i := range this.CapsAdd {
		if this.CapsAdd[i] != that1.CapsAdd[i] {
			return false
		}
	}
	if len(this.CapsDrop) != len(that1.CapsDrop) {
		return false
	}
	for i := range this.CapsDrop {
		if this.CapsDrop[i] != that1.CapsDrop[i] {
			return false
		}
	}
	if this.ProcMountKind != that1.ProcMountKind {
		return false
	}
	if !this.SelinuxOptions.Equal(that1.SelinuxOptions) {
		return false
	}
	return true
}
func (this *MountOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MountOptions)
	if !ok {
		that2, ok := that.(MountOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MountPath != that1.MountPath {
		return false
	}
	if this.SubPath != that1.SubPath {
		return false
	}
	if this.ReadOnly != that1.ReadOnly {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Options) != len(that1.Options) {
		return false
	}
	for i := range this.Options {
		if this.Options[i] != that1.Options[i] {
			return false
		}
	}
	return true
}
func (this *ContainerSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerSpec)
	if !ok {
		that2, ok := that.(ContainerSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Image != that1.Image {
		return false
	}
	if this.ImagePullPolicy != that1.ImagePullPolicy {
		return false
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if this.Command[i] != that1.Command[i] {
			return false
		}
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if this.Args[i] != that1.Args[i] {
			return false
		}
	}
	if this.WorkingDir != that1.WorkingDir {
		return false
	}
	if this.Stdin != that1.Stdin {
		return false
	}
	if this.StdinOnce != that1.StdinOnce {
		return false
	}
	if this.Tty != that1.Tty {
		return false
	}
	if len(this.Envs) != len(that1.Envs) {
		return false
	}
	for i := range this.Envs {
		if this.Envs[i] != that1.Envs[i] {
			return false
		}
	}
	if len(this.Mounts) != len(that1.Mounts) {
		return false
	}
	for i := range this.Mounts {
		if !this.Mounts[i].Equal(that1.Mounts[i]) {
			return false
		}
	}
	if !this.Security.Equal(that1.Security) {
		return false
	}
	return true
}
func (this *AuthConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthConfig)
	if !ok {
		that2, ok := that.(AuthConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Username != that1.Username {
		return false
	}
	if this.Password != that1.Password {
		return false
	}
	if this.Auth != that1.Auth {
		return false
	}
	if this.ServerAddress != that1.ServerAddress {
		return false
	}
	if this.IdentityToken != that1.IdentityToken {
		return false
	}
	if this.RegistryToken != that1.RegistryToken {
		return false
	}
	return true
}
func (this *CreateOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateOptions)
	if !ok {
		that2, ok := that.(CreateOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.RestartPolicy != that1.RestartPolicy {
		return false
	}
	if this.HostIpc != that1.HostIpc {
		return false
	}
	if this.HostNetwork != that1.HostNetwork {
		return false
	}
	if this.HostPid != that1.HostPid {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	if len(this.Containers) != len(that1.Containers) {
		return false
	}
	for i := range this.Containers {
		if !this.Containers[i].Equal(that1.Containers[i]) {
			return false
		}
	}
	if len(this.ImagePullAuthConfig) != len(that1.ImagePullAuthConfig) {
		return false
	}
	for i := range this.ImagePullAuthConfig {
		if !this.ImagePullAuthConfig[i].Equal(that1.ImagePullAuthConfig[i]) {
			return false
		}
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if !this.Ports[i].Equal(that1.Ports[i]) {
			return false
		}
	}
	if len(this.HostPaths) != len(that1.HostPaths) {
		return false
	}
	for i := range this.HostPaths {
		if this.HostPaths[i] != that1.HostPaths[i] {
			return false
		}
	}
	if len(this.VolumeData) != len(that1.VolumeData) {
		return false
	}
	for i := range this.VolumeData {
		if !this.VolumeData[i].Equal(that1.VolumeData[i]) {
			return false
		}
	}
	return true
}
func (this *DeleteOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteOptions)
	if !ok {
		that2, ok := that.(DeleteOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.GraceTime != that1.GraceTime {
		return false
	}
	return true
}
func (this *ListOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListOptions)
	if !ok {
		that2, ok := that.(ListOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.All != that1.All {
		return false
	}
	return true
}
func (this *LogOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogOptions)
	if !ok {
		that2, ok := that.(LogOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Container != that1.Container {
		return false
	}
	if this.Follow != that1.Follow {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Since != that1.Since {
		return false
	}
	if this.TailLines != that1.TailLines {
		return false
	}
	if this.BytesLimit != that1.BytesLimit {
		return false
	}
	return true
}
func (this *ExecOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecOptions)
	if !ok {
		that2, ok := that.(ExecOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Container != that1.Container {
		return false
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if this.Command[i] != that1.Command[i] {
			return false
		}
	}
	if this.Stdin != that1.Stdin {
		return false
	}
	if this.Stdout != that1.Stdout {
		return false
	}
	if this.Stderr != that1.Stderr {
		return false
	}
	if this.Tty != that1.Tty {
		return false
	}
	return true
}
func (this *PortForwardOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortForwardOptions)
	if !ok {
		that2, ok := that.(PortForwardOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Port != that1.Port {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	return true
}
func (this *InputOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InputOptions)
	if !ok {
		that2, ok := that.(InputOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *TtyResizeOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TtyResizeOptions)
	if !ok {
		that2, ok := that.(TtyResizeOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Cols != that1.Cols {
		return false
	}
	if this.Rows != that1.Rows {
		return false
	}
	return true
}
func (this *NodeCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&connectivity.NodeCmd{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&connectivity.PodCmd{")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodCmd_CreateOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_CreateOptions{` +
		`CreateOptions:` + fmt.Sprintf("%#v", this.CreateOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_DeleteOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_DeleteOptions{` +
		`DeleteOptions:` + fmt.Sprintf("%#v", this.DeleteOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_ListOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_ListOptions{` +
		`ListOptions:` + fmt.Sprintf("%#v", this.ListOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_LogOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_LogOptions{` +
		`LogOptions:` + fmt.Sprintf("%#v", this.LogOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_ExecOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_ExecOptions{` +
		`ExecOptions:` + fmt.Sprintf("%#v", this.ExecOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_PortForwardOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_PortForwardOptions{` +
		`PortForwardOptions:` + fmt.Sprintf("%#v", this.PortForwardOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_InputOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_InputOptions{` +
		`InputOptions:` + fmt.Sprintf("%#v", this.InputOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_ResizeOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_ResizeOptions{` +
		`ResizeOptions:` + fmt.Sprintf("%#v", this.ResizeOptions) + `}`}, ", ")
	return s
}
func (this *NamedData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&connectivity.NamedData{")
	keysForDataMap := make([]string, 0, len(this.DataMap))
	for k, _ := range this.DataMap {
		keysForDataMap = append(keysForDataMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDataMap)
	mapStringForDataMap := "map[string][]byte{"
	for _, k := range keysForDataMap {
		mapStringForDataMap += fmt.Sprintf("%#v: %#v,", k, this.DataMap[k])
	}
	mapStringForDataMap += "}"
	if this.DataMap != nil {
		s = append(s, "DataMap: "+mapStringForDataMap+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&connectivity.ContainerPort{")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "ContainerPort: "+fmt.Sprintf("%#v", this.ContainerPort)+",\n")
	s = append(s, "HostPort: "+fmt.Sprintf("%#v", this.HostPort)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SELinuxOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&connectivity.SELinuxOptions{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Level: "+fmt.Sprintf("%#v", this.Level)+",\n")
	s = append(s, "Role: "+fmt.Sprintf("%#v", this.Role)+",\n")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecurityOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&connectivity.SecurityOptions{")
	s = append(s, "Privileged: "+fmt.Sprintf("%#v", this.Privileged)+",\n")
	s = append(s, "AllowNewPrivileges: "+fmt.Sprintf("%#v", this.AllowNewPrivileges)+",\n")
	s = append(s, "NonRoot: "+fmt.Sprintf("%#v", this.NonRoot)+",\n")
	s = append(s, "ReadOnlyRootfs: "+fmt.Sprintf("%#v", this.ReadOnlyRootfs)+",\n")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "Group: "+fmt.Sprintf("%#v", this.Group)+",\n")
	s = append(s, "CapsAdd: "+fmt.Sprintf("%#v", this.CapsAdd)+",\n")
	s = append(s, "CapsDrop: "+fmt.Sprintf("%#v", this.CapsDrop)+",\n")
	s = append(s, "ProcMountKind: "+fmt.Sprintf("%#v", this.ProcMountKind)+",\n")
	if this.SelinuxOptions != nil {
		s = append(s, "SelinuxOptions: "+fmt.Sprintf("%#v", this.SelinuxOptions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MountOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&connectivity.MountOptions{")
	s = append(s, "MountPath: "+fmt.Sprintf("%#v", this.MountPath)+",\n")
	s = append(s, "SubPath: "+fmt.Sprintf("%#v", this.SubPath)+",\n")
	s = append(s, "ReadOnly: "+fmt.Sprintf("%#v", this.ReadOnly)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&connectivity.ContainerSpec{")
	s = append(s, "Image: "+fmt.Sprintf("%#v", this.Image)+",\n")
	s = append(s, "ImagePullPolicy: "+fmt.Sprintf("%#v", this.ImagePullPolicy)+",\n")
	s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	s = append(s, "Args: "+fmt.Sprintf("%#v", this.Args)+",\n")
	s = append(s, "WorkingDir: "+fmt.Sprintf("%#v", this.WorkingDir)+",\n")
	s = append(s, "Stdin: "+fmt.Sprintf("%#v", this.Stdin)+",\n")
	s = append(s, "StdinOnce: "+fmt.Sprintf("%#v", this.StdinOnce)+",\n")
	s = append(s, "Tty: "+fmt.Sprintf("%#v", this.Tty)+",\n")
	keysForEnvs := make([]string, 0, len(this.Envs))
	for k, _ := range this.Envs {
		keysForEnvs = append(keysForEnvs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEnvs)
	mapStringForEnvs := "map[string]string{"
	for _, k := range keysForEnvs {
		mapStringForEnvs += fmt.Sprintf("%#v: %#v,", k, this.Envs[k])
	}
	mapStringForEnvs += "}"
	if this.Envs != nil {
		s = append(s, "Envs: "+mapStringForEnvs+",\n")
	}
	keysForMounts := make([]string, 0, len(this.Mounts))
	for k, _ := range this.Mounts {
		keysForMounts = append(keysForMounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMounts)
	mapStringForMounts := "map[string]*MountOptions{"
	for _, k := range keysForMounts {
		mapStringForMounts += fmt.Sprintf("%#v: %#v,", k, this.Mounts[k])
	}
	mapStringForMounts += "}"
	if this.Mounts != nil {
		s = append(s, "Mounts: "+mapStringForMounts+",\n")
	}
	if this.Security != nil {
		s = append(s, "Security: "+fmt.Sprintf("%#v", this.Security)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthConfig) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&connectivity.AuthConfig{")
	s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	s = append(s, "Password: "+fmt.Sprintf("%#v", this.Password)+",\n")
	s = append(s, "Auth: "+fmt.Sprintf("%#v", this.Auth)+",\n")
	s = append(s, "ServerAddress: "+fmt.Sprintf("%#v", this.ServerAddress)+",\n")
	s = append(s, "IdentityToken: "+fmt.Sprintf("%#v", this.IdentityToken)+",\n")
	s = append(s, "RegistryToken: "+fmt.Sprintf("%#v", this.RegistryToken)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&connectivity.CreateOptions{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "RestartPolicy: "+fmt.Sprintf("%#v", this.RestartPolicy)+",\n")
	s = append(s, "HostIpc: "+fmt.Sprintf("%#v", this.HostIpc)+",\n")
	s = append(s, "HostNetwork: "+fmt.Sprintf("%#v", this.HostNetwork)+",\n")
	s = append(s, "HostPid: "+fmt.Sprintf("%#v", this.HostPid)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	keysForContainers := make([]string, 0, len(this.Containers))
	for k, _ := range this.Containers {
		keysForContainers = append(keysForContainers, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForContainers)
	mapStringForContainers := "map[string]*ContainerSpec{"
	for _, k := range keysForContainers {
		mapStringForContainers += fmt.Sprintf("%#v: %#v,", k, this.Containers[k])
	}
	mapStringForContainers += "}"
	if this.Containers != nil {
		s = append(s, "Containers: "+mapStringForContainers+",\n")
	}
	keysForImagePullAuthConfig := make([]string, 0, len(this.ImagePullAuthConfig))
	for k, _ := range this.ImagePullAuthConfig {
		keysForImagePullAuthConfig = append(keysForImagePullAuthConfig, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForImagePullAuthConfig)
	mapStringForImagePullAuthConfig := "map[string]*AuthConfig{"
	for _, k := range keysForImagePullAuthConfig {
		mapStringForImagePullAuthConfig += fmt.Sprintf("%#v: %#v,", k, this.ImagePullAuthConfig[k])
	}
	mapStringForImagePullAuthConfig += "}"
	if this.ImagePullAuthConfig != nil {
		s = append(s, "ImagePullAuthConfig: "+mapStringForImagePullAuthConfig+",\n")
	}
	keysForPorts := make([]string, 0, len(this.Ports))
	for k, _ := range this.Ports {
		keysForPorts = append(keysForPorts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPorts)
	mapStringForPorts := "map[string]*ContainerPort{"
	for _, k := range keysForPorts {
		mapStringForPorts += fmt.Sprintf("%#v: %#v,", k, this.Ports[k])
	}
	mapStringForPorts += "}"
	if this.Ports != nil {
		s = append(s, "Ports: "+mapStringForPorts+",\n")
	}
	keysForHostPaths := make([]string, 0, len(this.HostPaths))
	for k, _ := range this.HostPaths {
		keysForHostPaths = append(keysForHostPaths, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHostPaths)
	mapStringForHostPaths := "map[string]string{"
	for _, k := range keysForHostPaths {
		mapStringForHostPaths += fmt.Sprintf("%#v: %#v,", k, this.HostPaths[k])
	}
	mapStringForHostPaths += "}"
	if this.HostPaths != nil {
		s = append(s, "HostPaths: "+mapStringForHostPaths+",\n")
	}
	keysForVolumeData := make([]string, 0, len(this.VolumeData))
	for k, _ := range this.VolumeData {
		keysForVolumeData = append(keysForVolumeData, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVolumeData)
	mapStringForVolumeData := "map[string]*NamedData{"
	for _, k := range keysForVolumeData {
		mapStringForVolumeData += fmt.Sprintf("%#v: %#v,", k, this.VolumeData[k])
	}
	mapStringForVolumeData += "}"
	if this.VolumeData != nil {
		s = append(s, "VolumeData: "+mapStringForVolumeData+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&connectivity.DeleteOptions{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "GraceTime: "+fmt.Sprintf("%#v", this.GraceTime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&connectivity.ListOptions{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "All: "+fmt.Sprintf("%#v", this.All)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LogOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&connectivity.LogOptions{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	s = append(s, "Follow: "+fmt.Sprintf("%#v", this.Follow)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Since: "+fmt.Sprintf("%#v", this.Since)+",\n")
	s = append(s, "TailLines: "+fmt.Sprintf("%#v", this.TailLines)+",\n")
	s = append(s, "BytesLimit: "+fmt.Sprintf("%#v", this.BytesLimit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&connectivity.ExecOptions{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Container: "+fmt.Sprintf("%#v", this.Container)+",\n")
	s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	s = append(s, "Stdin: "+fmt.Sprintf("%#v", this.Stdin)+",\n")
	s = append(s, "Stdout: "+fmt.Sprintf("%#v", this.Stdout)+",\n")
	s = append(s, "Stderr: "+fmt.Sprintf("%#v", this.Stderr)+",\n")
	s = append(s, "Tty: "+fmt.Sprintf("%#v", this.Tty)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortForwardOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&connectivity.PortForwardOptions{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Port: "+fmt.Sprintf("%#v", this.Port)+",\n")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *InputOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&connectivity.InputOptions{")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TtyResizeOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&connectivity.TtyResizeOptions{")
	s = append(s, "Cols: "+fmt.Sprintf("%#v", this.Cols)+",\n")
	s = append(s, "Rows: "+fmt.Sprintf("%#v", this.Rows)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCmdDetail(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *NodeCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCmd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.Action))
	}
	return i, nil
}

func (m *PodCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodCmd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.Action))
	}
	if m.Options != nil {
		nn1, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *PodCmd_CreateOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CreateOptions != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.CreateOptions.Size()))
		n2, err := m.CreateOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *PodCmd_DeleteOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DeleteOptions != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.DeleteOptions.Size()))
		n3, err := m.DeleteOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *PodCmd_ListOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ListOptions != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.ListOptions.Size()))
		n4, err := m.ListOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *PodCmd_LogOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogOptions != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.LogOptions.Size()))
		n5, err := m.LogOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *PodCmd_ExecOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExecOptions != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.ExecOptions.Size()))
		n6, err := m.ExecOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *PodCmd_PortForwardOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PortForwardOptions != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.PortForwardOptions.Size()))
		n7, err := m.PortForwardOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *PodCmd_InputOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InputOptions != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.InputOptions.Size()))
		n8, err := m.InputOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *PodCmd_ResizeOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ResizeOptions != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.ResizeOptions.Size()))
		n9, err := m.ResizeOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *NamedData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DataMap) > 0 {
		for k, _ := range m.DataMap {
			dAtA[i] = 0xa
			i++
			v := m.DataMap[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovCmdDetail(uint64(len(v)))
			}
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + byteSize
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCmdDetail(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	return i, nil
}

func (m *ContainerPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerPort) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Protocol) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.ContainerPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.ContainerPort))
	}
	if m.HostPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.HostPort))
	}
	return i, nil
}

func (m *SELinuxOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SELinuxOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Level) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Level)))
		i += copy(dAtA[i:], m.Level)
	}
	if len(m.Role) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Role)))
		i += copy(dAtA[i:], m.Role)
	}
	if len(m.User) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.User)))
		i += copy(dAtA[i:], m.User)
	}
	return i, nil
}

func (m *SecurityOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Privileged {
		dAtA[i] = 0x8
		i++
		if m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AllowNewPrivileges {
		dAtA[i] = 0x10
		i++
		if m.AllowNewPrivileges {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NonRoot {
		dAtA[i] = 0x18
		i++
		if m.NonRoot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReadOnlyRootfs {
		dAtA[i] = 0x20
		i++
		if m.ReadOnlyRootfs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.User != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.User))
	}
	if m.Group != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.Group))
	}
	if len(m.CapsAdd) > 0 {
		for _, s := range m.CapsAdd {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.CapsDrop) > 0 {
		for _, s := range m.CapsDrop {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ProcMountKind != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.ProcMountKind))
	}
	if m.SelinuxOptions != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.SelinuxOptions.Size()))
		n10, err := m.SelinuxOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *MountOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MountOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MountPath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.MountPath)))
		i += copy(dAtA[i:], m.MountPath)
	}
	if len(m.SubPath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.SubPath)))
		i += copy(dAtA[i:], m.SubPath)
	}
	if m.ReadOnly {
		dAtA[i] = 0x18
		i++
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Options) > 0 {
		for _, s := range m.Options {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ContainerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Image) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if m.ImagePullPolicy != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.ImagePullPolicy))
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.WorkingDir) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.WorkingDir)))
		i += copy(dAtA[i:], m.WorkingDir)
	}
	if m.Stdin {
		dAtA[i] = 0x30
		i++
		if m.Stdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StdinOnce {
		dAtA[i] = 0x38
		i++
		if m.StdinOnce {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Tty {
		dAtA[i] = 0x40
		i++
		if m.Tty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Envs) > 0 {
		for k, _ := range m.Envs {
			dAtA[i] = 0x5a
			i++
			v := m.Envs[k]
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + 1 + len(v) + sovCmdDetail(uint64(len(v)))
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Mounts) > 0 {
		for k, _ := range m.Mounts {
			dAtA[i] = 0x62
			i++
			v := m.Mounts[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCmdDetail(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + msgSize
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCmdDetail(dAtA, i, uint64(v.Size()))
				n11, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n11
			}
		}
	}
	if m.Security != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.Security.Size()))
		n12, err := m.Security.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *AuthConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.Auth) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Auth)))
		i += copy(dAtA[i:], m.Auth)
	}
	if len(m.ServerAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.ServerAddress)))
		i += copy(dAtA[i:], m.ServerAddress)
	}
	if len(m.IdentityToken) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.IdentityToken)))
		i += copy(dAtA[i:], m.IdentityToken)
	}
	if len(m.RegistryToken) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.RegistryToken)))
		i += copy(dAtA[i:], m.RegistryToken)
	}
	return i, nil
}

func (m *CreateOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PodUid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.PodUid)))
		i += copy(dAtA[i:], m.PodUid)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.RestartPolicy != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.RestartPolicy))
	}
	if m.HostIpc {
		dAtA[i] = 0x28
		i++
		if m.HostIpc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HostNetwork {
		dAtA[i] = 0x30
		i++
		if m.HostNetwork {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HostPid {
		dAtA[i] = 0x38
		i++
		if m.HostPid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if len(m.Containers) > 0 {
		for k, _ := range m.Containers {
			dAtA[i] = 0x5a
			i++
			v := m.Containers[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCmdDetail(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + msgSize
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCmdDetail(dAtA, i, uint64(v.Size()))
				n13, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n13
			}
		}
	}
	if len(m.ImagePullAuthConfig) > 0 {
		for k, _ := range m.ImagePullAuthConfig {
			dAtA[i] = 0x62
			i++
			v := m.ImagePullAuthConfig[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCmdDetail(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + msgSize
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCmdDetail(dAtA, i, uint64(v.Size()))
				n14, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n14
			}
		}
	}
	if len(m.Ports) > 0 {
		for k, _ := range m.Ports {
			dAtA[i] = 0x6a
			i++
			v := m.Ports[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCmdDetail(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + msgSize
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCmdDetail(dAtA, i, uint64(v.Size()))
				n15, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n15
			}
		}
	}
	if len(m.HostPaths) > 0 {
		for k, _ := range m.HostPaths {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			v := m.HostPaths[k]
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + 1 + len(v) + sovCmdDetail(uint64(len(v)))
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.VolumeData) > 0 {
		for k, _ := range m.VolumeData {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.VolumeData[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCmdDetail(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + msgSize
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCmdDetail(dAtA, i, uint64(v.Size()))
				n16, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n16
			}
		}
	}
	return i, nil
}

func (m *DeleteOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PodUid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.PodUid)))
		i += copy(dAtA[i:], m.PodUid)
	}
	if m.GraceTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.GraceTime))
	}
	return i, nil
}

func (m *ListOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.All {
		dAtA[i] = 0x18
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LogOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PodUid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.PodUid)))
		i += copy(dAtA[i:], m.PodUid)
	}
	if len(m.Container) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Container)))
		i += copy(dAtA[i:], m.Container)
	}
	if m.Follow {
		dAtA[i] = 0x18
		i++
		if m.Follow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Timestamp {
		dAtA[i] = 0x20
		i++
		if m.Timestamp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Since != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.Since))
	}
	if m.TailLines != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.TailLines))
	}
	if m.BytesLimit != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.BytesLimit))
	}
	return i, nil
}

func (m *ExecOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PodUid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.PodUid)))
		i += copy(dAtA[i:], m.PodUid)
	}
	if len(m.Container) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Container)))
		i += copy(dAtA[i:], m.Container)
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Stdin {
		dAtA[i] = 0x20
		i++
		if m.Stdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Stdout {
		dAtA[i] = 0x28
		i++
		if m.Stdout {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Stderr {
		dAtA[i] = 0x30
		i++
		if m.Stderr {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Tty {
		dAtA[i] = 0x38
		i++
		if m.Tty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PortForwardOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortForwardOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PodUid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.PodUid)))
		i += copy(dAtA[i:], m.PodUid)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.Port))
	}
	if len(m.Protocol) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	return i, nil
}

func (m *InputOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *TtyResizeOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TtyResizeOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cols != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.Cols))
	}
	if m.Rows != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.Rows))
	}
	return i, nil
}

func encodeVarintCmdDetail(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NodeCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovCmdDetail(uint64(m.Action))
	}
	return n
}

func (m *PodCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovCmdDetail(uint64(m.Action))
	}
	if m.Options != nil {
		n += m.Options.Size()
	}
	return n
}

func (m *PodCmd_CreateOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateOptions != nil {
		l = m.CreateOptions.Size()
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *PodCmd_DeleteOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteOptions != nil {
		l = m.DeleteOptions.Size()
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *PodCmd_ListOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ListOptions != nil {
		l = m.ListOptions.Size()
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *PodCmd_LogOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogOptions != nil {
		l = m.LogOptions.Size()
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *PodCmd_ExecOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExecOptions != nil {
		l = m.ExecOptions.Size()
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *PodCmd_PortForwardOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortForwardOptions != nil {
		l = m.PortForwardOptions.Size()
		n += 2 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *PodCmd_InputOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InputOptions != nil {
		l = m.InputOptions.Size()
		n += 2 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *PodCmd_ResizeOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResizeOptions != nil {
		l = m.ResizeOptions.Size()
		n += 2 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *NamedData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DataMap) > 0 {
		for k, v := range m.DataMap {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovCmdDetail(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ContainerPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.ContainerPort != 0 {
		n += 1 + sovCmdDetail(uint64(m.ContainerPort))
	}
	if m.HostPort != 0 {
		n += 1 + sovCmdDetail(uint64(m.HostPort))
	}
	return n
}

func (m *SELinuxOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.Level)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}

func (m *SecurityOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Privileged {
		n += 2
	}
	if m.AllowNewPrivileges {
		n += 2
	}
	if m.NonRoot {
		n += 2
	}
	if m.ReadOnlyRootfs {
		n += 2
	}
	if m.User != 0 {
		n += 1 + sovCmdDetail(uint64(m.User))
	}
	if m.Group != 0 {
		n += 1 + sovCmdDetail(uint64(m.Group))
	}
	if len(m.CapsAdd) > 0 {
		for _, s := range m.CapsAdd {
			l = len(s)
			n += 1 + l + sovCmdDetail(uint64(l))
		}
	}
	if len(m.CapsDrop) > 0 {
		for _, s := range m.CapsDrop {
			l = len(s)
			n += 1 + l + sovCmdDetail(uint64(l))
		}
	}
	if m.ProcMountKind != 0 {
		n += 1 + sovCmdDetail(uint64(m.ProcMountKind))
	}
	if m.SelinuxOptions != nil {
		l = m.SelinuxOptions.Size()
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}

func (m *MountOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MountPath)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.SubPath)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.ReadOnly {
		n += 2
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, s := range m.Options {
			l = len(s)
			n += 1 + l + sovCmdDetail(uint64(l))
		}
	}
	return n
}

func (m *ContainerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.ImagePullPolicy != 0 {
		n += 1 + sovCmdDetail(uint64(m.ImagePullPolicy))
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovCmdDetail(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovCmdDetail(uint64(l))
		}
	}
	l = len(m.WorkingDir)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.Stdin {
		n += 2
	}
	if m.StdinOnce {
		n += 2
	}
	if m.Tty {
		n += 2
	}
	if len(m.Envs) > 0 {
		for k, v := range m.Envs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + 1 + len(v) + sovCmdDetail(uint64(len(v)))
			n += mapEntrySize + 1 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	if len(m.Mounts) > 0 {
		for k, v := range m.Mounts {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdDetail(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	if m.Security != nil {
		l = m.Security.Size()
		n += 2 + l + sovCmdDetail(uint64(l))
	}
	return n
}

func (m *AuthConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.Auth)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.ServerAddress)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.IdentityToken)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.RegistryToken)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}

func (m *CreateOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.RestartPolicy != 0 {
		n += 1 + sovCmdDetail(uint64(m.RestartPolicy))
	}
	if m.HostIpc {
		n += 2
	}
	if m.HostNetwork {
		n += 2
	}
	if m.HostPid {
		n += 2
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if len(m.Containers) > 0 {
		for k, v := range m.Containers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdDetail(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	if len(m.ImagePullAuthConfig) > 0 {
		for k, v := range m.ImagePullAuthConfig {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdDetail(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	if len(m.Ports) > 0 {
		for k, v := range m.Ports {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdDetail(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	if len(m.HostPaths) > 0 {
		for k, v := range m.HostPaths {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + 1 + len(v) + sovCmdDetail(uint64(len(v)))
			n += mapEntrySize + 2 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	if len(m.VolumeData) > 0 {
		for k, v := range m.VolumeData {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdDetail(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DeleteOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.GraceTime != 0 {
		n += 1 + sovCmdDetail(uint64(m.GraceTime))
	}
	return n
}

func (m *ListOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.All {
		n += 2
	}
	return n
}

func (m *LogOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.Follow {
		n += 2
	}
	if m.Timestamp {
		n += 2
	}
	if m.Since != 0 {
		n += 1 + sovCmdDetail(uint64(m.Since))
	}
	if m.TailLines != 0 {
		n += 1 + sovCmdDetail(uint64(m.TailLines))
	}
	if m.BytesLimit != 0 {
		n += 1 + sovCmdDetail(uint64(m.BytesLimit))
	}
	return n
}

func (m *ExecOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovCmdDetail(uint64(l))
		}
	}
	if m.Stdin {
		n += 2
	}
	if m.Stdout {
		n += 2
	}
	if m.Stderr {
		n += 2
	}
	if m.Tty {
		n += 2
	}
	return n
}

func (m *PortForwardOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovCmdDetail(uint64(m.Port))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}

func (m *InputOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}

func (m *TtyResizeOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cols != 0 {
		n += 1 + sovCmdDetail(uint64(m.Cols))
	}
	if m.Rows != 0 {
		n += 1 + sovCmdDetail(uint64(m.Rows))
	}
	return n
}

func sovCmdDetail(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCmdDetail(x uint64) (n int) {
	return sovCmdDetail(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *NodeCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeCmd{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd{`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`Options:` + fmt.Sprintf("%v", this.Options) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_CreateOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_CreateOptions{`,
		`CreateOptions:` + strings.Replace(fmt.Sprintf("%v", this.CreateOptions), "CreateOptions", "CreateOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_DeleteOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_DeleteOptions{`,
		`DeleteOptions:` + strings.Replace(fmt.Sprintf("%v", this.DeleteOptions), "DeleteOptions", "DeleteOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_ListOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_ListOptions{`,
		`ListOptions:` + strings.Replace(fmt.Sprintf("%v", this.ListOptions), "ListOptions", "ListOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_LogOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_LogOptions{`,
		`LogOptions:` + strings.Replace(fmt.Sprintf("%v", this.LogOptions), "LogOptions", "LogOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_ExecOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_ExecOptions{`,
		`ExecOptions:` + strings.Replace(fmt.Sprintf("%v", this.ExecOptions), "ExecOptions", "ExecOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_PortForwardOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_PortForwardOptions{`,
		`PortForwardOptions:` + strings.Replace(fmt.Sprintf("%v", this.PortForwardOptions), "PortForwardOptions", "PortForwardOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_InputOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_InputOptions{`,
		`InputOptions:` + strings.Replace(fmt.Sprintf("%v", this.InputOptions), "InputOptions", "InputOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_ResizeOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_ResizeOptions{`,
		`ResizeOptions:` + strings.Replace(fmt.Sprintf("%v", this.ResizeOptions), "TtyResizeOptions", "TtyResizeOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamedData) String() string {
	if this == nil {
		return "nil"
	}
	keysForDataMap := make([]string, 0, len(this.DataMap))
	for k, _ := range this.DataMap {
		keysForDataMap = append(keysForDataMap, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForDataMap)
	mapStringForDataMap := "map[string][]byte{"
	for _, k := range keysForDataMap {
		mapStringForDataMap += fmt.Sprintf("%v: %v,", k, this.DataMap[k])
	}
	mapStringForDataMap += "}"
	s := strings.Join([]string{`&NamedData{`,
		`DataMap:` + mapStringForDataMap + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerPort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerPort{`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`ContainerPort:` + fmt.Sprintf("%v", this.ContainerPort) + `,`,
		`HostPort:` + fmt.Sprintf("%v", this.HostPort) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SELinuxOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SELinuxOptions{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Level:` + fmt.Sprintf("%v", this.Level) + `,`,
		`Role:` + fmt.Sprintf("%v", this.Role) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecurityOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecurityOptions{`,
		`Privileged:` + fmt.Sprintf("%v", this.Privileged) + `,`,
		`AllowNewPrivileges:` + fmt.Sprintf("%v", this.AllowNewPrivileges) + `,`,
		`NonRoot:` + fmt.Sprintf("%v", this.NonRoot) + `,`,
		`ReadOnlyRootfs:` + fmt.Sprintf("%v", this.ReadOnlyRootfs) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`Group:` + fmt.Sprintf("%v", this.Group) + `,`,
		`CapsAdd:` + fmt.Sprintf("%v", this.CapsAdd) + `,`,
		`CapsDrop:` + fmt.Sprintf("%v", this.CapsDrop) + `,`,
		`ProcMountKind:` + fmt.Sprintf("%v", this.ProcMountKind) + `,`,
		`SelinuxOptions:` + strings.Replace(fmt.Sprintf("%v", this.SelinuxOptions), "SELinuxOptions", "SELinuxOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MountOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MountOptions{`,
		`MountPath:` + fmt.Sprintf("%v", this.MountPath) + `,`,
		`SubPath:` + fmt.Sprintf("%v", this.SubPath) + `,`,
		`ReadOnly:` + fmt.Sprintf("%v", this.ReadOnly) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Options:` + fmt.Sprintf("%v", this.Options) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerSpec) String() string {
	if this == nil {
		return "nil"
	}
	keysForEnvs := make([]string, 0, len(this.Envs))
	for k, _ := range this.Envs {
		keysForEnvs = append(keysForEnvs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEnvs)
	mapStringForEnvs := "map[string]string{"
	for _, k := range keysForEnvs {
		mapStringForEnvs += fmt.Sprintf("%v: %v,", k, this.Envs[k])
	}
	mapStringForEnvs += "}"
	keysForMounts := make([]string, 0, len(this.Mounts))
	for k, _ := range this.Mounts {
		keysForMounts = append(keysForMounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForMounts)
	mapStringForMounts := "map[string]*MountOptions{"
	for _, k := range keysForMounts {
		mapStringForMounts += fmt.Sprintf("%v: %v,", k, this.Mounts[k])
	}
	mapStringForMounts += "}"
	s := strings.Join([]string{`&ContainerSpec{`,
		`Image:` + fmt.Sprintf("%v", this.Image) + `,`,
		`ImagePullPolicy:` + fmt.Sprintf("%v", this.ImagePullPolicy) + `,`,
		`Command:` + fmt.Sprintf("%v", this.Command) + `,`,
		`Args:` + fmt.Sprintf("%v", this.Args) + `,`,
		`WorkingDir:` + fmt.Sprintf("%v", this.WorkingDir) + `,`,
		`Stdin:` + fmt.Sprintf("%v", this.Stdin) + `,`,
		`StdinOnce:` + fmt.Sprintf("%v", this.StdinOnce) + `,`,
		`Tty:` + fmt.Sprintf("%v", this.Tty) + `,`,
		`Envs:` + mapStringForEnvs + `,`,
		`Mounts:` + mapStringForMounts + `,`,
		`Security:` + strings.Replace(fmt.Sprintf("%v", this.Security), "SecurityOptions", "SecurityOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AuthConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AuthConfig{`,
		`Username:` + fmt.Sprintf("%v", this.Username) + `,`,
		`Password:` + fmt.Sprintf("%v", this.Password) + `,`,
		`Auth:` + fmt.Sprintf("%v", this.Auth) + `,`,
		`ServerAddress:` + fmt.Sprintf("%v", this.ServerAddress) + `,`,
		`IdentityToken:` + fmt.Sprintf("%v", this.IdentityToken) + `,`,
		`RegistryToken:` + fmt.Sprintf("%v", this.RegistryToken) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateOptions) String() string {
	if this == nil {
		return "nil"
	}
	keysForContainers := make([]string, 0, len(this.Containers))
	for k, _ := range this.Containers {
		keysForContainers = append(keysForContainers, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForContainers)
	mapStringForContainers := "map[string]*ContainerSpec{"
	for _, k := range keysForContainers {
		mapStringForContainers += fmt.Sprintf("%v: %v,", k, this.Containers[k])
	}
	mapStringForContainers += "}"
	keysForImagePullAuthConfig := make([]string, 0, len(this.ImagePullAuthConfig))
	for k, _ := range this.ImagePullAuthConfig {
		keysForImagePullAuthConfig = append(keysForImagePullAuthConfig, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForImagePullAuthConfig)
	mapStringForImagePullAuthConfig := "map[string]*AuthConfig{"
	for _, k := range keysForImagePullAuthConfig {
		mapStringForImagePullAuthConfig += fmt.Sprintf("%v: %v,", k, this.ImagePullAuthConfig[k])
	}
	mapStringForImagePullAuthConfig += "}"
	keysForPorts := make([]string, 0, len(this.Ports))
	for k, _ := range this.Ports {
		keysForPorts = append(keysForPorts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPorts)
	mapStringForPorts := "map[string]*ContainerPort{"
	for _, k := range keysForPorts {
		mapStringForPorts += fmt.Sprintf("%v: %v,", k, this.Ports[k])
	}
	mapStringForPorts += "}"
	keysForHostPaths := make([]string, 0, len(this.HostPaths))
	for k, _ := range this.HostPaths {
		keysForHostPaths = append(keysForHostPaths, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHostPaths)
	mapStringForHostPaths := "map[string]string{"
	for _, k := range keysForHostPaths {
		mapStringForHostPaths += fmt.Sprintf("%v: %v,", k, this.HostPaths[k])
	}
	mapStringForHostPaths += "}"
	keysForVolumeData := make([]string, 0, len(this.VolumeData))
	for k, _ := range this.VolumeData {
		keysForVolumeData = append(keysForVolumeData, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVolumeData)
	mapStringForVolumeData := "map[string]*NamedData{"
	for _, k := range keysForVolumeData {
		mapStringForVolumeData += fmt.Sprintf("%v: %v,", k, this.VolumeData[k])
	}
	mapStringForVolumeData += "}"
	s := strings.Join([]string{`&CreateOptions{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`RestartPolicy:` + fmt.Sprintf("%v", this.RestartPolicy) + `,`,
		`HostIpc:` + fmt.Sprintf("%v", this.HostIpc) + `,`,
		`HostNetwork:` + fmt.Sprintf("%v", this.HostNetwork) + `,`,
		`HostPid:` + fmt.Sprintf("%v", this.HostPid) + `,`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`Containers:` + mapStringForContainers + `,`,
		`ImagePullAuthConfig:` + mapStringForImagePullAuthConfig + `,`,
		`Ports:` + mapStringForPorts + `,`,
		`HostPaths:` + mapStringForHostPaths + `,`,
		`VolumeData:` + mapStringForVolumeData + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteOptions{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`GraceTime:` + fmt.Sprintf("%v", this.GraceTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListOptions{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`All:` + fmt.Sprintf("%v", this.All) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LogOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LogOptions{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Container:` + fmt.Sprintf("%v", this.Container) + `,`,
		`Follow:` + fmt.Sprintf("%v", this.Follow) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Since:` + fmt.Sprintf("%v", this.Since) + `,`,
		`TailLines:` + fmt.Sprintf("%v", this.TailLines) + `,`,
		`BytesLimit:` + fmt.Sprintf("%v", this.BytesLimit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExecOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExecOptions{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Container:` + fmt.Sprintf("%v", this.Container) + `,`,
		`Command:` + fmt.Sprintf("%v", this.Command) + `,`,
		`Stdin:` + fmt.Sprintf("%v", this.Stdin) + `,`,
		`Stdout:` + fmt.Sprintf("%v", this.Stdout) + `,`,
		`Stderr:` + fmt.Sprintf("%v", this.Stderr) + `,`,
		`Tty:` + fmt.Sprintf("%v", this.Tty) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortForwardOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortForwardOptions{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InputOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InputOptions{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TtyResizeOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TtyResizeOptions{`,
		`Cols:` + fmt.Sprintf("%v", this.Cols) + `,`,
		`Rows:` + fmt.Sprintf("%v", this.Rows) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCmdDetail(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *NodeCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= NodeCmd_Action(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= PodCmd_Action(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_CreateOptions{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_DeleteOptions{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ListOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_ListOptions{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_LogOptions{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExecOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_ExecOptions{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortForwardOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PortForwardOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_PortForwardOptions{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InputOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_InputOptions{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResizeOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TtyResizeOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_ResizeOptions{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataMap == nil {
				m.DataMap = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DataMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			m.ContainerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			m.HostPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SELinuxOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SELinuxOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SELinuxOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Level = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowNewPrivileges", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowNewPrivileges = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonRoot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NonRoot = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnlyRootfs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnlyRootfs = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			m.User = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.User |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapsAdd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapsAdd = append(m.CapsAdd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapsDrop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapsDrop = append(m.CapsDrop, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcMountKind", wireType)
			}
			m.ProcMountKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcMountKind |= SecurityOptions_ProcMountKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelinuxOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelinuxOptions == nil {
				m.SelinuxOptions = &SELinuxOptions{}
			}
			if err := m.SelinuxOptions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MountOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MountOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MountOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullPolicy", wireType)
			}
			m.ImagePullPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImagePullPolicy |= ImagePullPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkingDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdin = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StdinOnce", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StdinOnce = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tty = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Envs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Envs == nil {
				m.Envs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Envs[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mounts == nil {
				m.Mounts = make(map[string]*MountOptions)
			}
			var mapkey string
			var mapvalue *MountOptions
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MountOptions{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Mounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Security", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Security == nil {
				m.Security = &SecurityOptions{}
			}
			if err := m.Security.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Auth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdentityToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistryToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegistryToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartPolicy", wireType)
			}
			m.RestartPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestartPolicy |= RestartPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIpc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostIpc = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostNetwork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostNetwork = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostPid = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Containers == nil {
				m.Containers = make(map[string]*ContainerSpec)
			}
			var mapkey string
			var mapvalue *ContainerSpec
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ContainerSpec{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Containers[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullAuthConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImagePullAuthConfig == nil {
				m.ImagePullAuthConfig = make(map[string]*AuthConfig)
			}
			var mapkey string
			var mapvalue *AuthConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AuthConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ImagePullAuthConfig[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ports == nil {
				m.Ports = make(map[string]*ContainerPort)
			}
			var mapkey string
			var mapvalue *ContainerPort
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ContainerPort{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ports[mapkey] = mapvalue
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostPaths == nil {
				m.HostPaths = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HostPaths[mapkey] = mapvalue
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeData == nil {
				m.VolumeData = make(map[string]*NamedData)
			}
			var mapkey string
			var mapvalue *NamedData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NamedData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VolumeData[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraceTime", wireType)
			}
			m.GraceTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GraceTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Follow = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timestamp = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Since", wireType)
			}
			m.Since = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Since |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TailLines", wireType)
			}
			m.TailLines = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TailLines |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesLimit", wireType)
			}
			m.BytesLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdin = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdout", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdout = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stderr", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stderr = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tty = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortForwardOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortForwardOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortForwardOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TtyResizeOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TtyResizeOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TtyResizeOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			m.Rows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rows |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCmdDetail(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCmdDetail
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCmdDetail
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCmdDetail(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCmdDetail
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCmdDetail = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCmdDetail   = fmt.Errorf("proto: integer overflow")
)
