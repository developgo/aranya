// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cmd_detail.proto

package connectivity

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type NodeCmd_NodeAction int32

const (
	GetInfoAll    NodeCmd_NodeAction = 0
	GetSystemInfo NodeCmd_NodeAction = 1
	GetResources  NodeCmd_NodeAction = 2
	GetConditions NodeCmd_NodeAction = 3
)

var NodeCmd_NodeAction_name = map[int32]string{
	0: "GetInfoAll",
	1: "GetSystemInfo",
	2: "GetResources",
	3: "GetConditions",
}

var NodeCmd_NodeAction_value = map[string]int32{
	"GetInfoAll":    0,
	"GetSystemInfo": 1,
	"GetResources":  2,
	"GetConditions": 3,
}

func (NodeCmd_NodeAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{0, 0}
}

type ImageCmd_ImageAction int32

const (
	ListImages ImageCmd_ImageAction = 0
)

var ImageCmd_ImageAction_name = map[int32]string{
	0: "ListImages",
}

var ImageCmd_ImageAction_value = map[string]int32{
	"ListImages": 0,
}

func (ImageCmd_ImageAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{1, 0}
}

type PodCmd_PodAction int32

const (
	// Create a new pod in device
	CreatePod PodCmd_PodAction = 0
	// Delete a existing pod in device
	DeletePod PodCmd_PodAction = 1
	// List all managed pod in device
	ListPods PodCmd_PodAction = 3
	// Execute commands in existing container
	Exec PodCmd_PodAction = 11
	// Attach to existing container
	Attach PodCmd_PodAction = 12
	// Get container/node log
	Log PodCmd_PodAction = 13
	// Port forward in pod
	PortForward PodCmd_PodAction = 14
	// user input or application data to
	// usually this action happens in Exec, Attach, PortForward session
	Input PodCmd_PodAction = 15
	// user tty resize
	// usually this action happens in Exec, Attach session when tty is enabled
	ResizeTty PodCmd_PodAction = 16
)

var PodCmd_PodAction_name = map[int32]string{
	0:  "CreatePod",
	1:  "DeletePod",
	3:  "ListPods",
	11: "Exec",
	12: "Attach",
	13: "Log",
	14: "PortForward",
	15: "Input",
	16: "ResizeTty",
}

var PodCmd_PodAction_value = map[string]int32{
	"CreatePod":   0,
	"DeletePod":   1,
	"ListPods":    3,
	"Exec":        11,
	"Attach":      12,
	"Log":         13,
	"PortForward": 14,
	"Input":       15,
	"ResizeTty":   16,
}

func (PodCmd_PodAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{2, 0}
}

type NodeCmd struct {
	Action NodeCmd_NodeAction `protobuf:"varint,1,opt,name=action,proto3,enum=connectivity.NodeCmd_NodeAction" json:"action,omitempty"`
}

func (m *NodeCmd) Reset()      { *m = NodeCmd{} }
func (*NodeCmd) ProtoMessage() {}
func (*NodeCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{0}
}
func (m *NodeCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeCmd.Merge(m, src)
}
func (m *NodeCmd) XXX_Size() int {
	return m.Size()
}
func (m *NodeCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeCmd.DiscardUnknown(m)
}

var xxx_messageInfo_NodeCmd proto.InternalMessageInfo

func (m *NodeCmd) GetAction() NodeCmd_NodeAction {
	if m != nil {
		return m.Action
	}
	return GetInfoAll
}

func (*NodeCmd) XXX_MessageName() string {
	return "connectivity.NodeCmd"
}

type ImageCmd struct {
	Action ImageCmd_ImageAction `protobuf:"varint,1,opt,name=action,proto3,enum=connectivity.ImageCmd_ImageAction" json:"action,omitempty"`
}

func (m *ImageCmd) Reset()      { *m = ImageCmd{} }
func (*ImageCmd) ProtoMessage() {}
func (*ImageCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{1}
}
func (m *ImageCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImageCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImageCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImageCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageCmd.Merge(m, src)
}
func (m *ImageCmd) XXX_Size() int {
	return m.Size()
}
func (m *ImageCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageCmd.DiscardUnknown(m)
}

var xxx_messageInfo_ImageCmd proto.InternalMessageInfo

func (m *ImageCmd) GetAction() ImageCmd_ImageAction {
	if m != nil {
		return m.Action
	}
	return ListImages
}

func (*ImageCmd) XXX_MessageName() string {
	return "connectivity.ImageCmd"
}

type PodCmd struct {
	// action type
	Action PodCmd_PodAction `protobuf:"varint,1,opt,name=action,proto3,enum=connectivity.PodCmd_PodAction" json:"action,omitempty"`
	// options for action
	//
	// Types that are valid to be assigned to Options:
	//	*PodCmd_CreateOptions
	//	*PodCmd_DeleteOptions
	//	*PodCmd_ListOptions
	//	*PodCmd_LogOptions
	//	*PodCmd_ExecOptions
	//	*PodCmd_PortForwardOptions
	//	*PodCmd_InputOptions
	//	*PodCmd_ResizeOptions
	Options isPodCmd_Options `protobuf_oneof:"options"`
}

func (m *PodCmd) Reset()      { *m = PodCmd{} }
func (*PodCmd) ProtoMessage() {}
func (*PodCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{2}
}
func (m *PodCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PodCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PodCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PodCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PodCmd.Merge(m, src)
}
func (m *PodCmd) XXX_Size() int {
	return m.Size()
}
func (m *PodCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_PodCmd.DiscardUnknown(m)
}

var xxx_messageInfo_PodCmd proto.InternalMessageInfo

type isPodCmd_Options interface {
	isPodCmd_Options()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PodCmd_CreateOptions struct {
	CreateOptions *CreateOptions `protobuf:"bytes,11,opt,name=create_options,json=createOptions,proto3,oneof"`
}
type PodCmd_DeleteOptions struct {
	DeleteOptions *DeleteOptions `protobuf:"bytes,12,opt,name=delete_options,json=deleteOptions,proto3,oneof"`
}
type PodCmd_ListOptions struct {
	ListOptions *ListOptions `protobuf:"bytes,13,opt,name=list_options,json=listOptions,proto3,oneof"`
}
type PodCmd_LogOptions struct {
	LogOptions *LogOptions `protobuf:"bytes,14,opt,name=log_options,json=logOptions,proto3,oneof"`
}
type PodCmd_ExecOptions struct {
	ExecOptions *ExecOptions `protobuf:"bytes,15,opt,name=exec_options,json=execOptions,proto3,oneof"`
}
type PodCmd_PortForwardOptions struct {
	PortForwardOptions *PortForwardOptions `protobuf:"bytes,16,opt,name=port_forward_options,json=portForwardOptions,proto3,oneof"`
}
type PodCmd_InputOptions struct {
	InputOptions *InputOptions `protobuf:"bytes,17,opt,name=input_options,json=inputOptions,proto3,oneof"`
}
type PodCmd_ResizeOptions struct {
	ResizeOptions *TtyResizeOptions `protobuf:"bytes,18,opt,name=resize_options,json=resizeOptions,proto3,oneof"`
}

func (*PodCmd_CreateOptions) isPodCmd_Options()      {}
func (*PodCmd_DeleteOptions) isPodCmd_Options()      {}
func (*PodCmd_ListOptions) isPodCmd_Options()        {}
func (*PodCmd_LogOptions) isPodCmd_Options()         {}
func (*PodCmd_ExecOptions) isPodCmd_Options()        {}
func (*PodCmd_PortForwardOptions) isPodCmd_Options() {}
func (*PodCmd_InputOptions) isPodCmd_Options()       {}
func (*PodCmd_ResizeOptions) isPodCmd_Options()      {}

func (m *PodCmd) GetOptions() isPodCmd_Options {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *PodCmd) GetAction() PodCmd_PodAction {
	if m != nil {
		return m.Action
	}
	return CreatePod
}

func (m *PodCmd) GetCreateOptions() *CreateOptions {
	if x, ok := m.GetOptions().(*PodCmd_CreateOptions); ok {
		return x.CreateOptions
	}
	return nil
}

func (m *PodCmd) GetDeleteOptions() *DeleteOptions {
	if x, ok := m.GetOptions().(*PodCmd_DeleteOptions); ok {
		return x.DeleteOptions
	}
	return nil
}

func (m *PodCmd) GetListOptions() *ListOptions {
	if x, ok := m.GetOptions().(*PodCmd_ListOptions); ok {
		return x.ListOptions
	}
	return nil
}

func (m *PodCmd) GetLogOptions() *LogOptions {
	if x, ok := m.GetOptions().(*PodCmd_LogOptions); ok {
		return x.LogOptions
	}
	return nil
}

func (m *PodCmd) GetExecOptions() *ExecOptions {
	if x, ok := m.GetOptions().(*PodCmd_ExecOptions); ok {
		return x.ExecOptions
	}
	return nil
}

func (m *PodCmd) GetPortForwardOptions() *PortForwardOptions {
	if x, ok := m.GetOptions().(*PodCmd_PortForwardOptions); ok {
		return x.PortForwardOptions
	}
	return nil
}

func (m *PodCmd) GetInputOptions() *InputOptions {
	if x, ok := m.GetOptions().(*PodCmd_InputOptions); ok {
		return x.InputOptions
	}
	return nil
}

func (m *PodCmd) GetResizeOptions() *TtyResizeOptions {
	if x, ok := m.GetOptions().(*PodCmd_ResizeOptions); ok {
		return x.ResizeOptions
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PodCmd) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PodCmd_OneofMarshaler, _PodCmd_OneofUnmarshaler, _PodCmd_OneofSizer, []interface{}{
		(*PodCmd_CreateOptions)(nil),
		(*PodCmd_DeleteOptions)(nil),
		(*PodCmd_ListOptions)(nil),
		(*PodCmd_LogOptions)(nil),
		(*PodCmd_ExecOptions)(nil),
		(*PodCmd_PortForwardOptions)(nil),
		(*PodCmd_InputOptions)(nil),
		(*PodCmd_ResizeOptions)(nil),
	}
}

func _PodCmd_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PodCmd)
	// options
	switch x := m.Options.(type) {
	case *PodCmd_CreateOptions:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CreateOptions); err != nil {
			return err
		}
	case *PodCmd_DeleteOptions:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DeleteOptions); err != nil {
			return err
		}
	case *PodCmd_ListOptions:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ListOptions); err != nil {
			return err
		}
	case *PodCmd_LogOptions:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogOptions); err != nil {
			return err
		}
	case *PodCmd_ExecOptions:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ExecOptions); err != nil {
			return err
		}
	case *PodCmd_PortForwardOptions:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PortForwardOptions); err != nil {
			return err
		}
	case *PodCmd_InputOptions:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.InputOptions); err != nil {
			return err
		}
	case *PodCmd_ResizeOptions:
		_ = b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ResizeOptions); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PodCmd.Options has unexpected type %T", x)
	}
	return nil
}

func _PodCmd_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PodCmd)
	switch tag {
	case 11: // options.create_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CreateOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_CreateOptions{msg}
		return true, err
	case 12: // options.delete_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeleteOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_DeleteOptions{msg}
		return true, err
	case 13: // options.list_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ListOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_ListOptions{msg}
		return true, err
	case 14: // options.log_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_LogOptions{msg}
		return true, err
	case 15: // options.exec_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ExecOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_ExecOptions{msg}
		return true, err
	case 16: // options.port_forward_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PortForwardOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_PortForwardOptions{msg}
		return true, err
	case 17: // options.input_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InputOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_InputOptions{msg}
		return true, err
	case 18: // options.resize_options
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TtyResizeOptions)
		err := b.DecodeMessage(msg)
		m.Options = &PodCmd_ResizeOptions{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PodCmd_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PodCmd)
	// options
	switch x := m.Options.(type) {
	case *PodCmd_CreateOptions:
		s := proto.Size(x.CreateOptions)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodCmd_DeleteOptions:
		s := proto.Size(x.DeleteOptions)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodCmd_ListOptions:
		s := proto.Size(x.ListOptions)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodCmd_LogOptions:
		s := proto.Size(x.LogOptions)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodCmd_ExecOptions:
		s := proto.Size(x.ExecOptions)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodCmd_PortForwardOptions:
		s := proto.Size(x.PortForwardOptions)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodCmd_InputOptions:
		s := proto.Size(x.InputOptions)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PodCmd_ResizeOptions:
		s := proto.Size(x.ResizeOptions)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func (*PodCmd) XXX_MessageName() string {
	return "connectivity.PodCmd"
}

type NamedData struct {
	Data map[string][]byte `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NamedData) Reset()      { *m = NamedData{} }
func (*NamedData) ProtoMessage() {}
func (*NamedData) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{3}
}
func (m *NamedData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NamedData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NamedData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NamedData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NamedData.Merge(m, src)
}
func (m *NamedData) XXX_Size() int {
	return m.Size()
}
func (m *NamedData) XXX_DiscardUnknown() {
	xxx_messageInfo_NamedData.DiscardUnknown(m)
}

var xxx_messageInfo_NamedData proto.InternalMessageInfo

func (m *NamedData) GetData() map[string][]byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (*NamedData) XXX_MessageName() string {
	return "connectivity.NamedData"
}

type ContainerPort struct {
	Protocol      string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	HostPort      int32  `protobuf:"varint,2,opt,name=host_port,json=hostPort,proto3" json:"host_port,omitempty"`
	ContainerPort int32  `protobuf:"varint,3,opt,name=container_port,json=containerPort,proto3" json:"container_port,omitempty"`
	HostIp        string `protobuf:"bytes,4,opt,name=host_ip,json=hostIp,proto3" json:"host_ip,omitempty"`
}

func (m *ContainerPort) Reset()      { *m = ContainerPort{} }
func (*ContainerPort) ProtoMessage() {}
func (*ContainerPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{4}
}
func (m *ContainerPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerPort.Merge(m, src)
}
func (m *ContainerPort) XXX_Size() int {
	return m.Size()
}
func (m *ContainerPort) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerPort.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerPort proto.InternalMessageInfo

func (m *ContainerPort) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *ContainerPort) GetHostPort() int32 {
	if m != nil {
		return m.HostPort
	}
	return 0
}

func (m *ContainerPort) GetContainerPort() int32 {
	if m != nil {
		return m.ContainerPort
	}
	return 0
}

func (m *ContainerPort) GetHostIp() string {
	if m != nil {
		return m.HostIp
	}
	return ""
}

func (*ContainerPort) XXX_MessageName() string {
	return "connectivity.ContainerPort"
}

type VolumeMount struct {
	MountPath     string   `protobuf:"bytes,1,opt,name=mount_path,json=mountPath,proto3" json:"mount_path,omitempty"`
	VolumeSubPath string   `protobuf:"bytes,2,opt,name=volume_sub_path,json=volumeSubPath,proto3" json:"volume_sub_path,omitempty"`
	ReadOnly      bool     `protobuf:"varint,3,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	Type          string   `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	Options       []string `protobuf:"bytes,5,rep,name=options,proto3" json:"options,omitempty"`
}

func (m *VolumeMount) Reset()      { *m = VolumeMount{} }
func (*VolumeMount) ProtoMessage() {}
func (*VolumeMount) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{5}
}
func (m *VolumeMount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VolumeMount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VolumeMount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VolumeMount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeMount.Merge(m, src)
}
func (m *VolumeMount) XXX_Size() int {
	return m.Size()
}
func (m *VolumeMount) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeMount.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeMount proto.InternalMessageInfo

func (m *VolumeMount) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *VolumeMount) GetVolumeSubPath() string {
	if m != nil {
		return m.VolumeSubPath
	}
	return ""
}

func (m *VolumeMount) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *VolumeMount) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *VolumeMount) GetOptions() []string {
	if m != nil {
		return m.Options
	}
	return nil
}

func (*VolumeMount) XXX_MessageName() string {
	return "connectivity.VolumeMount"
}

type ContainerSpec struct {
	// container image name to pull
	Image           string `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	ImagePullPolicy string `protobuf:"bytes,2,opt,name=image_pull_policy,json=imagePullPolicy,proto3" json:"image_pull_policy,omitempty"`
	// Command (ENTRYPOINT in Dockerfile)
	Command []string `protobuf:"bytes,3,rep,name=command,proto3" json:"command,omitempty"`
	// Args (CMD in Dockerfile)
	Args       []string `protobuf:"bytes,4,rep,name=args,proto3" json:"args,omitempty"`
	WorkingDir string   `protobuf:"bytes,5,opt,name=working_dir,json=workingDir,proto3" json:"working_dir,omitempty"`
	Stdin      bool     `protobuf:"varint,6,opt,name=stdin,proto3" json:"stdin,omitempty"`
	Tty        bool     `protobuf:"varint,7,opt,name=tty,proto3" json:"tty,omitempty"`
	// key: port name
	// value: port map and spec
	Ports map[string]*ContainerPort `protobuf:"bytes,11,rep,name=ports,proto3" json:"ports,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// key: env key
	// value: env value
	Envs map[string]string `protobuf:"bytes,12,rep,name=envs,proto3" json:"envs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// key: volume name
	// value: volume mount spec
	VolumeMounts map[string]*VolumeMount `protobuf:"bytes,13,rep,name=volume_mounts,json=volumeMounts,proto3" json:"volume_mounts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	//
	// security opts
	//
	Privileged         bool `protobuf:"varint,21,opt,name=privileged,proto3" json:"privileged,omitempty"`
	AllowNewPrivileges bool `protobuf:"varint,22,opt,name=allow_new_privileges,json=allowNewPrivileges,proto3" json:"allow_new_privileges,omitempty"`
}

func (m *ContainerSpec) Reset()      { *m = ContainerSpec{} }
func (*ContainerSpec) ProtoMessage() {}
func (*ContainerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{6}
}
func (m *ContainerSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerSpec.Merge(m, src)
}
func (m *ContainerSpec) XXX_Size() int {
	return m.Size()
}
func (m *ContainerSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerSpec proto.InternalMessageInfo

func (m *ContainerSpec) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *ContainerSpec) GetImagePullPolicy() string {
	if m != nil {
		return m.ImagePullPolicy
	}
	return ""
}

func (m *ContainerSpec) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ContainerSpec) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *ContainerSpec) GetWorkingDir() string {
	if m != nil {
		return m.WorkingDir
	}
	return ""
}

func (m *ContainerSpec) GetStdin() bool {
	if m != nil {
		return m.Stdin
	}
	return false
}

func (m *ContainerSpec) GetTty() bool {
	if m != nil {
		return m.Tty
	}
	return false
}

func (m *ContainerSpec) GetPorts() map[string]*ContainerPort {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *ContainerSpec) GetEnvs() map[string]string {
	if m != nil {
		return m.Envs
	}
	return nil
}

func (m *ContainerSpec) GetVolumeMounts() map[string]*VolumeMount {
	if m != nil {
		return m.VolumeMounts
	}
	return nil
}

func (m *ContainerSpec) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}

func (m *ContainerSpec) GetAllowNewPrivileges() bool {
	if m != nil {
		return m.AllowNewPrivileges
	}
	return false
}

func (*ContainerSpec) XXX_MessageName() string {
	return "connectivity.ContainerSpec"
}

type CreateOptions struct {
	// kubernetes pod uid
	PodUid    string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Name      string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// key: container name in the pod
	// value: container creation spec
	Containers map[string]*ContainerSpec `protobuf:"bytes,11,rep,name=containers,proto3" json:"containers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// key: image name
	// value: bytes of criRuntime.AuthConfig
	// used to pull private images
	ImagePullAuthConfig map[string][]byte `protobuf:"bytes,12,rep,name=image_pull_auth_config,json=imagePullAuthConfig,proto3" json:"image_pull_auth_config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// key: volume name
	// value: host path
	HostVolumes map[string]string `protobuf:"bytes,21,rep,name=host_volumes,json=hostVolumes,proto3" json:"host_volumes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// key: volume name
	// value: data from {ConfigMap, Secret}
	// used to populate file(s) in container(s)
	VolumeData map[string]*NamedData `protobuf:"bytes,22,rep,name=volume_data,json=volumeData,proto3" json:"volume_data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// other options
	HostIpc     bool   `protobuf:"varint,31,opt,name=host_ipc,json=hostIpc,proto3" json:"host_ipc,omitempty"`
	HostNetwork bool   `protobuf:"varint,32,opt,name=host_network,json=hostNetwork,proto3" json:"host_network,omitempty"`
	HostPid     bool   `protobuf:"varint,33,opt,name=host_pid,json=hostPid,proto3" json:"host_pid,omitempty"`
	Hostname    string `protobuf:"bytes,34,opt,name=hostname,proto3" json:"hostname,omitempty"`
}

func (m *CreateOptions) Reset()      { *m = CreateOptions{} }
func (*CreateOptions) ProtoMessage() {}
func (*CreateOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{7}
}
func (m *CreateOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateOptions.Merge(m, src)
}
func (m *CreateOptions) XXX_Size() int {
	return m.Size()
}
func (m *CreateOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateOptions.DiscardUnknown(m)
}

var xxx_messageInfo_CreateOptions proto.InternalMessageInfo

func (m *CreateOptions) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *CreateOptions) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CreateOptions) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateOptions) GetContainers() map[string]*ContainerSpec {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *CreateOptions) GetImagePullAuthConfig() map[string][]byte {
	if m != nil {
		return m.ImagePullAuthConfig
	}
	return nil
}

func (m *CreateOptions) GetHostVolumes() map[string]string {
	if m != nil {
		return m.HostVolumes
	}
	return nil
}

func (m *CreateOptions) GetVolumeData() map[string]*NamedData {
	if m != nil {
		return m.VolumeData
	}
	return nil
}

func (m *CreateOptions) GetHostIpc() bool {
	if m != nil {
		return m.HostIpc
	}
	return false
}

func (m *CreateOptions) GetHostNetwork() bool {
	if m != nil {
		return m.HostNetwork
	}
	return false
}

func (m *CreateOptions) GetHostPid() bool {
	if m != nil {
		return m.HostPid
	}
	return false
}

func (m *CreateOptions) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (*CreateOptions) XXX_MessageName() string {
	return "connectivity.CreateOptions"
}

type DeleteOptions struct {
	// pods to delete
	PodUid    string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	GraceTime int64  `protobuf:"varint,10,opt,name=grace_time,json=graceTime,proto3" json:"grace_time,omitempty"`
}

func (m *DeleteOptions) Reset()      { *m = DeleteOptions{} }
func (*DeleteOptions) ProtoMessage() {}
func (*DeleteOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{8}
}
func (m *DeleteOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteOptions.Merge(m, src)
}
func (m *DeleteOptions) XXX_Size() int {
	return m.Size()
}
func (m *DeleteOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteOptions.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteOptions proto.InternalMessageInfo

func (m *DeleteOptions) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *DeleteOptions) GetGraceTime() int64 {
	if m != nil {
		return m.GraceTime
	}
	return 0
}

func (*DeleteOptions) XXX_MessageName() string {
	return "connectivity.DeleteOptions"
}

type ListOptions struct {
	// pod namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// pod name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// show all pods available
	All bool `protobuf:"varint,3,opt,name=all,proto3" json:"all,omitempty"`
}

func (m *ListOptions) Reset()      { *m = ListOptions{} }
func (*ListOptions) ProtoMessage() {}
func (*ListOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{9}
}
func (m *ListOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListOptions.Merge(m, src)
}
func (m *ListOptions) XXX_Size() int {
	return m.Size()
}
func (m *ListOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ListOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ListOptions proto.InternalMessageInfo

func (m *ListOptions) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ListOptions) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListOptions) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (*ListOptions) XXX_MessageName() string {
	return "connectivity.ListOptions"
}

type LogOptions struct {
	PodUid string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	// Types that are valid to be assigned to Options:
	//	*LogOptions_OptionsV1
	Options isLogOptions_Options `protobuf_oneof:"options"`
}

func (m *LogOptions) Reset()      { *m = LogOptions{} }
func (*LogOptions) ProtoMessage() {}
func (*LogOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{10}
}
func (m *LogOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogOptions.Merge(m, src)
}
func (m *LogOptions) XXX_Size() int {
	return m.Size()
}
func (m *LogOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_LogOptions.DiscardUnknown(m)
}

var xxx_messageInfo_LogOptions proto.InternalMessageInfo

type isLogOptions_Options interface {
	isLogOptions_Options()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type LogOptions_OptionsV1 struct {
	OptionsV1 []byte `protobuf:"bytes,10,opt,name=options_v1,json=optionsV1,proto3,oneof"`
}

func (*LogOptions_OptionsV1) isLogOptions_Options() {}

func (m *LogOptions) GetOptions() isLogOptions_Options {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *LogOptions) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *LogOptions) GetOptionsV1() []byte {
	if x, ok := m.GetOptions().(*LogOptions_OptionsV1); ok {
		return x.OptionsV1
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LogOptions) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LogOptions_OneofMarshaler, _LogOptions_OneofUnmarshaler, _LogOptions_OneofSizer, []interface{}{
		(*LogOptions_OptionsV1)(nil),
	}
}

func _LogOptions_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LogOptions)
	// options
	switch x := m.Options.(type) {
	case *LogOptions_OptionsV1:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.OptionsV1)
	case nil:
	default:
		return fmt.Errorf("LogOptions.Options has unexpected type %T", x)
	}
	return nil
}

func _LogOptions_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LogOptions)
	switch tag {
	case 10: // options.options_v1
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Options = &LogOptions_OptionsV1{x}
		return true, err
	default:
		return false, nil
	}
}

func _LogOptions_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LogOptions)
	// options
	switch x := m.Options.(type) {
	case *LogOptions_OptionsV1:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.OptionsV1)))
		n += len(x.OptionsV1)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func (*LogOptions) XXX_MessageName() string {
	return "connectivity.LogOptions"
}

type ExecOptions struct {
	PodUid string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	// Types that are valid to be assigned to Options:
	//	*ExecOptions_OptionsV1
	Options isExecOptions_Options `protobuf_oneof:"options"`
}

func (m *ExecOptions) Reset()      { *m = ExecOptions{} }
func (*ExecOptions) ProtoMessage() {}
func (*ExecOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{11}
}
func (m *ExecOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecOptions.Merge(m, src)
}
func (m *ExecOptions) XXX_Size() int {
	return m.Size()
}
func (m *ExecOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ExecOptions proto.InternalMessageInfo

type isExecOptions_Options interface {
	isExecOptions_Options()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type ExecOptions_OptionsV1 struct {
	OptionsV1 []byte `protobuf:"bytes,10,opt,name=options_v1,json=optionsV1,proto3,oneof"`
}

func (*ExecOptions_OptionsV1) isExecOptions_Options() {}

func (m *ExecOptions) GetOptions() isExecOptions_Options {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *ExecOptions) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *ExecOptions) GetOptionsV1() []byte {
	if x, ok := m.GetOptions().(*ExecOptions_OptionsV1); ok {
		return x.OptionsV1
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ExecOptions) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ExecOptions_OneofMarshaler, _ExecOptions_OneofUnmarshaler, _ExecOptions_OneofSizer, []interface{}{
		(*ExecOptions_OptionsV1)(nil),
	}
}

func _ExecOptions_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ExecOptions)
	// options
	switch x := m.Options.(type) {
	case *ExecOptions_OptionsV1:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.OptionsV1)
	case nil:
	default:
		return fmt.Errorf("ExecOptions.Options has unexpected type %T", x)
	}
	return nil
}

func _ExecOptions_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ExecOptions)
	switch tag {
	case 10: // options.options_v1
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Options = &ExecOptions_OptionsV1{x}
		return true, err
	default:
		return false, nil
	}
}

func _ExecOptions_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ExecOptions)
	// options
	switch x := m.Options.(type) {
	case *ExecOptions_OptionsV1:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.OptionsV1)))
		n += len(x.OptionsV1)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func (*ExecOptions) XXX_MessageName() string {
	return "connectivity.ExecOptions"
}

type PortForwardOptions struct {
	PodUid string `protobuf:"bytes,1,opt,name=pod_uid,json=podUid,proto3" json:"pod_uid,omitempty"`
	// Types that are valid to be assigned to Options:
	//	*PortForwardOptions_OptionsV1
	Options isPortForwardOptions_Options `protobuf_oneof:"options"`
}

func (m *PortForwardOptions) Reset()      { *m = PortForwardOptions{} }
func (*PortForwardOptions) ProtoMessage() {}
func (*PortForwardOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{12}
}
func (m *PortForwardOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PortForwardOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PortForwardOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PortForwardOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortForwardOptions.Merge(m, src)
}
func (m *PortForwardOptions) XXX_Size() int {
	return m.Size()
}
func (m *PortForwardOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_PortForwardOptions.DiscardUnknown(m)
}

var xxx_messageInfo_PortForwardOptions proto.InternalMessageInfo

type isPortForwardOptions_Options interface {
	isPortForwardOptions_Options()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type PortForwardOptions_OptionsV1 struct {
	OptionsV1 []byte `protobuf:"bytes,10,opt,name=options_v1,json=optionsV1,proto3,oneof"`
}

func (*PortForwardOptions_OptionsV1) isPortForwardOptions_Options() {}

func (m *PortForwardOptions) GetOptions() isPortForwardOptions_Options {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *PortForwardOptions) GetPodUid() string {
	if m != nil {
		return m.PodUid
	}
	return ""
}

func (m *PortForwardOptions) GetOptionsV1() []byte {
	if x, ok := m.GetOptions().(*PortForwardOptions_OptionsV1); ok {
		return x.OptionsV1
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PortForwardOptions) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PortForwardOptions_OneofMarshaler, _PortForwardOptions_OneofUnmarshaler, _PortForwardOptions_OneofSizer, []interface{}{
		(*PortForwardOptions_OptionsV1)(nil),
	}
}

func _PortForwardOptions_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PortForwardOptions)
	// options
	switch x := m.Options.(type) {
	case *PortForwardOptions_OptionsV1:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.OptionsV1)
	case nil:
	default:
		return fmt.Errorf("PortForwardOptions.Options has unexpected type %T", x)
	}
	return nil
}

func _PortForwardOptions_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PortForwardOptions)
	switch tag {
	case 10: // options.options_v1
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Options = &PortForwardOptions_OptionsV1{x}
		return true, err
	default:
		return false, nil
	}
}

func _PortForwardOptions_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PortForwardOptions)
	// options
	switch x := m.Options.(type) {
	case *PortForwardOptions_OptionsV1:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.OptionsV1)))
		n += len(x.OptionsV1)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func (*PortForwardOptions) XXX_MessageName() string {
	return "connectivity.PortForwardOptions"
}

type InputOptions struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *InputOptions) Reset()      { *m = InputOptions{} }
func (*InputOptions) ProtoMessage() {}
func (*InputOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{13}
}
func (m *InputOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputOptions.Merge(m, src)
}
func (m *InputOptions) XXX_Size() int {
	return m.Size()
}
func (m *InputOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_InputOptions.DiscardUnknown(m)
}

var xxx_messageInfo_InputOptions proto.InternalMessageInfo

func (m *InputOptions) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (*InputOptions) XXX_MessageName() string {
	return "connectivity.InputOptions"
}

type TtyResizeOptions struct {
	Cols uint32 `protobuf:"varint,1,opt,name=cols,proto3" json:"cols,omitempty"`
	Rows uint32 `protobuf:"varint,2,opt,name=rows,proto3" json:"rows,omitempty"`
}

func (m *TtyResizeOptions) Reset()      { *m = TtyResizeOptions{} }
func (*TtyResizeOptions) ProtoMessage() {}
func (*TtyResizeOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_1571bcd24e248579, []int{14}
}
func (m *TtyResizeOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TtyResizeOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TtyResizeOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TtyResizeOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TtyResizeOptions.Merge(m, src)
}
func (m *TtyResizeOptions) XXX_Size() int {
	return m.Size()
}
func (m *TtyResizeOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_TtyResizeOptions.DiscardUnknown(m)
}

var xxx_messageInfo_TtyResizeOptions proto.InternalMessageInfo

func (m *TtyResizeOptions) GetCols() uint32 {
	if m != nil {
		return m.Cols
	}
	return 0
}

func (m *TtyResizeOptions) GetRows() uint32 {
	if m != nil {
		return m.Rows
	}
	return 0
}

func (*TtyResizeOptions) XXX_MessageName() string {
	return "connectivity.TtyResizeOptions"
}
func init() {
	proto.RegisterEnum("connectivity.NodeCmd_NodeAction", NodeCmd_NodeAction_name, NodeCmd_NodeAction_value)
	proto.RegisterEnum("connectivity.ImageCmd_ImageAction", ImageCmd_ImageAction_name, ImageCmd_ImageAction_value)
	proto.RegisterEnum("connectivity.PodCmd_PodAction", PodCmd_PodAction_name, PodCmd_PodAction_value)
	proto.RegisterType((*NodeCmd)(nil), "connectivity.NodeCmd")
	proto.RegisterType((*ImageCmd)(nil), "connectivity.ImageCmd")
	proto.RegisterType((*PodCmd)(nil), "connectivity.PodCmd")
	proto.RegisterType((*NamedData)(nil), "connectivity.NamedData")
	proto.RegisterMapType((map[string][]byte)(nil), "connectivity.NamedData.DataEntry")
	proto.RegisterType((*ContainerPort)(nil), "connectivity.ContainerPort")
	proto.RegisterType((*VolumeMount)(nil), "connectivity.VolumeMount")
	proto.RegisterType((*ContainerSpec)(nil), "connectivity.ContainerSpec")
	proto.RegisterMapType((map[string]string)(nil), "connectivity.ContainerSpec.EnvsEntry")
	proto.RegisterMapType((map[string]*ContainerPort)(nil), "connectivity.ContainerSpec.PortsEntry")
	proto.RegisterMapType((map[string]*VolumeMount)(nil), "connectivity.ContainerSpec.VolumeMountsEntry")
	proto.RegisterType((*CreateOptions)(nil), "connectivity.CreateOptions")
	proto.RegisterMapType((map[string]*ContainerSpec)(nil), "connectivity.CreateOptions.ContainersEntry")
	proto.RegisterMapType((map[string]string)(nil), "connectivity.CreateOptions.HostVolumesEntry")
	proto.RegisterMapType((map[string][]byte)(nil), "connectivity.CreateOptions.ImagePullAuthConfigEntry")
	proto.RegisterMapType((map[string]*NamedData)(nil), "connectivity.CreateOptions.VolumeDataEntry")
	proto.RegisterType((*DeleteOptions)(nil), "connectivity.DeleteOptions")
	proto.RegisterType((*ListOptions)(nil), "connectivity.ListOptions")
	proto.RegisterType((*LogOptions)(nil), "connectivity.LogOptions")
	proto.RegisterType((*ExecOptions)(nil), "connectivity.ExecOptions")
	proto.RegisterType((*PortForwardOptions)(nil), "connectivity.PortForwardOptions")
	proto.RegisterType((*InputOptions)(nil), "connectivity.InputOptions")
	proto.RegisterType((*TtyResizeOptions)(nil), "connectivity.TtyResizeOptions")
}

func init() { proto.RegisterFile("cmd_detail.proto", fileDescriptor_1571bcd24e248579) }

var fileDescriptor_1571bcd24e248579 = []byte{
	// 1464 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcb, 0x73, 0xd3, 0x56,
	0x17, 0xb7, 0xe2, 0xd8, 0xb1, 0x8e, 0xed, 0x44, 0xb9, 0x1f, 0x0f, 0x11, 0x3e, 0x84, 0xf1, 0x0c,
	0x4c, 0xe6, 0xfb, 0x4a, 0x28, 0xf4, 0x45, 0x69, 0x87, 0x99, 0x90, 0x40, 0xc8, 0x94, 0x06, 0x23,
	0x02, 0x33, 0x65, 0xa3, 0x51, 0xa4, 0x1b, 0xfb, 0x0e, 0xb2, 0xae, 0x46, 0xba, 0x76, 0x70, 0xbb,
	0x69, 0x77, 0x5d, 0x76, 0xdb, 0x55, 0xb7, 0xfd, 0x53, 0x58, 0x32, 0xd3, 0x0d, 0xcb, 0xe2, 0x6c,
	0xba, 0x64, 0xdd, 0x55, 0xe7, 0x1e, 0x29, 0xd2, 0xb5, 0xf3, 0x60, 0xe8, 0xb0, 0xb1, 0xcf, 0xf9,
	0xe9, 0x9c, 0xdf, 0x3d, 0x3a, 0x2f, 0x5d, 0x30, 0xbc, 0xbe, 0xef, 0xf8, 0x54, 0xb8, 0x2c, 0x58,
	0x89, 0x62, 0x2e, 0x38, 0x69, 0x78, 0x3c, 0x0c, 0xa9, 0x27, 0xd8, 0x90, 0x89, 0xd1, 0xd2, 0xd5,
	0x2e, 0x13, 0xbd, 0xc1, 0xce, 0x8a, 0xc7, 0xfb, 0xd7, 0xba, 0xbc, 0xcb, 0xaf, 0xa1, 0xd1, 0xce,
	0x60, 0x17, 0x35, 0x54, 0x50, 0x4a, 0x9d, 0xdb, 0xbf, 0x6a, 0x30, 0xb7, 0xc5, 0x7d, 0xba, 0xd6,
	0xf7, 0xc9, 0x4d, 0xa8, 0xba, 0x9e, 0x60, 0x3c, 0x34, 0xb5, 0x96, 0xb6, 0x3c, 0x7f, 0xa3, 0xb5,
	0xa2, 0x32, 0xaf, 0x64, 0x66, 0xf8, 0xbf, 0x8a, 0x76, 0x76, 0x66, 0xdf, 0xde, 0x06, 0x28, 0x50,
	0x32, 0x0f, 0xb0, 0x41, 0xc5, 0x66, 0xb8, 0xcb, 0x57, 0x83, 0xc0, 0x28, 0x91, 0x45, 0x68, 0x6e,
	0x50, 0xf1, 0x78, 0x94, 0x08, 0xda, 0x97, 0xa8, 0xa1, 0x11, 0x03, 0x1a, 0x1b, 0x54, 0xd8, 0x34,
	0xe1, 0x83, 0xd8, 0xa3, 0x89, 0x31, 0x93, 0x19, 0xad, 0xf1, 0xd0, 0x67, 0x92, 0x24, 0x31, 0xca,
	0x6d, 0x0a, 0xb5, 0xcd, 0xbe, 0xdb, 0xc5, 0xd8, 0x6e, 0x4d, 0xc5, 0xd6, 0x9e, 0x8c, 0xed, 0xc0,
	0x2e, 0x15, 0xa6, 0xa2, 0xbb, 0x00, 0x75, 0x05, 0x96, 0xe1, 0x3d, 0x60, 0x89, 0x40, 0x28, 0x31,
	0x4a, 0xed, 0xbf, 0x2b, 0x50, 0xed, 0x70, 0x5f, 0x9e, 0xf2, 0xf9, 0xd4, 0x29, 0xd6, 0xe4, 0x29,
	0xa9, 0x95, 0xfc, 0x9b, 0x3c, 0x81, 0xac, 0xc3, 0xbc, 0x17, 0x53, 0x57, 0x50, 0x87, 0x47, 0x18,
	0xbd, 0x59, 0x6f, 0x69, 0xcb, 0xf5, 0x1b, 0xe7, 0x27, 0xfd, 0xd7, 0xd0, 0xe6, 0x61, 0x6a, 0x72,
	0xbf, 0x64, 0x37, 0x3d, 0x15, 0x90, 0x2c, 0x3e, 0x0d, 0xa8, 0xc2, 0xd2, 0x38, 0x8a, 0x65, 0x1d,
	0x6d, 0x14, 0x16, 0x5f, 0x05, 0xc8, 0x6d, 0x68, 0x04, 0x2c, 0x11, 0x39, 0x47, 0x13, 0x39, 0xce,
	0x4d, 0x72, 0xc8, 0x04, 0x14, 0x0c, 0xf5, 0xa0, 0x50, 0xc9, 0x57, 0x50, 0x0f, 0x78, 0x37, 0x77,
	0x9f, 0x47, 0x77, 0x73, 0xca, 0x9d, 0x77, 0x0b, 0x6f, 0x08, 0x72, 0x4d, 0x1e, 0x4e, 0x5f, 0x50,
	0x2f, 0xf7, 0x5e, 0x38, 0xea, 0xf0, 0xbb, 0x2f, 0xa8, 0xa7, 0x1c, 0x4e, 0x0b, 0x95, 0x6c, 0xc3,
	0xa9, 0x88, 0xc7, 0xc2, 0xd9, 0xe5, 0xf1, 0x9e, 0x1b, 0xfb, 0x39, 0x8f, 0x81, 0x3c, 0xad, 0xe9,
	0x72, 0xc4, 0xe2, 0x5e, 0x6a, 0x58, 0xd0, 0x91, 0xe8, 0x10, 0x4a, 0x56, 0xa1, 0xc9, 0xc2, 0x68,
	0x50, 0xe4, 0x64, 0x11, 0xe9, 0x96, 0xa6, 0x7a, 0x48, 0x9a, 0x14, 0x44, 0x0d, 0xa6, 0xe8, 0x64,
	0x03, 0xe6, 0x63, 0x9a, 0xb0, 0xef, 0x8b, 0xda, 0x10, 0xe4, 0x98, 0xea, 0x90, 0x6d, 0x31, 0xb2,
	0xd1, 0x4c, 0x29, 0x4f, 0xac, 0x02, 0xed, 0x9f, 0x34, 0xd0, 0xf3, 0x06, 0x22, 0x4d, 0xd0, 0xd3,
	0xa6, 0xe8, 0x70, 0xdf, 0x28, 0x49, 0x35, 0xad, 0xae, 0x54, 0x35, 0xd2, 0x80, 0x9a, 0x2c, 0x54,
	0x87, 0xfb, 0x89, 0x51, 0x26, 0x35, 0x98, 0x95, 0x99, 0x33, 0xea, 0x04, 0xa0, 0xba, 0x2a, 0x84,
	0xeb, 0xf5, 0x8c, 0x06, 0x99, 0x83, 0xf2, 0x03, 0xde, 0x35, 0x9a, 0x64, 0x01, 0xea, 0x4a, 0x42,
	0x8c, 0x79, 0xa2, 0x43, 0x05, 0x5f, 0xc9, 0x58, 0x90, 0xbc, 0x69, 0x58, 0xdb, 0x62, 0x64, 0x18,
	0x77, 0x74, 0x98, 0xcb, 0xde, 0xa2, 0xfd, 0x03, 0xe8, 0x5b, 0x6e, 0x9f, 0xfa, 0xeb, 0xae, 0x70,
	0xc9, 0x67, 0x30, 0xeb, 0xbb, 0xc2, 0x35, 0xb5, 0x56, 0x79, 0xb9, 0x7e, 0xe3, 0xd2, 0xd4, 0xf8,
	0x1f, 0x98, 0xad, 0xc8, 0x9f, 0xbb, 0xa1, 0x88, 0x47, 0x36, 0x9a, 0x2f, 0x7d, 0x01, 0x7a, 0x0e,
	0x11, 0x03, 0xca, 0xcf, 0xe9, 0x08, 0xe7, 0x47, 0xb7, 0xa5, 0x48, 0x4e, 0x41, 0x65, 0xe8, 0x06,
	0x03, 0x6a, 0xce, 0xb4, 0xb4, 0xe5, 0x86, 0x9d, 0x2a, 0xb7, 0x66, 0x6e, 0x6a, 0xed, 0x9f, 0x35,
	0x68, 0xae, 0xf1, 0x50, 0xb8, 0x2c, 0xa4, 0xb1, 0x0c, 0x9e, 0x2c, 0x41, 0x0d, 0xf7, 0x92, 0xc7,
	0x83, 0x8c, 0x22, 0xd7, 0xc9, 0x79, 0xd0, 0x7b, 0x3c, 0x11, 0x8e, 0x2c, 0x30, 0x72, 0x55, 0xec,
	0x9a, 0x04, 0xd0, 0xf1, 0x32, 0xcc, 0x7b, 0x07, 0x4c, 0xa9, 0x45, 0x19, 0x2d, 0x9a, 0xde, 0x04,
	0xff, 0x59, 0x98, 0x43, 0x0e, 0x16, 0x99, 0xb3, 0x48, 0x5f, 0x95, 0xea, 0x66, 0xd4, 0xfe, 0x4d,
	0x83, 0xfa, 0x53, 0x1e, 0x0c, 0xfa, 0xf4, 0x5b, 0x3e, 0x08, 0x05, 0xb9, 0x00, 0xd0, 0x97, 0x82,
	0x13, 0xb9, 0xa2, 0x97, 0x85, 0xa2, 0x23, 0xd2, 0x71, 0x45, 0x8f, 0x5c, 0x81, 0x85, 0x21, 0x5a,
	0x3b, 0xc9, 0x60, 0x27, 0xb5, 0x99, 0x41, 0x9b, 0x66, 0x0a, 0x3f, 0x1e, 0xec, 0xa0, 0xdd, 0x79,
	0xd0, 0x63, 0xea, 0xfa, 0x0e, 0x0f, 0x83, 0x11, 0x46, 0x54, 0xb3, 0x6b, 0x12, 0x78, 0x18, 0x06,
	0x23, 0x42, 0x60, 0x56, 0x8c, 0x22, 0x9a, 0x45, 0x82, 0x32, 0x31, 0xf3, 0xd2, 0x98, 0x95, 0x56,
	0x79, 0x59, 0xb7, 0xf3, 0x4a, 0xfd, 0x51, 0x51, 0x92, 0xf5, 0x38, 0xa2, 0x9e, 0x4c, 0x2c, 0x93,
	0x4b, 0x2c, 0x0b, 0x2f, 0x55, 0xc8, 0xff, 0x60, 0x11, 0x05, 0x27, 0x1a, 0x04, 0x81, 0x13, 0xf1,
	0x80, 0x79, 0xa3, 0x2c, 0xb8, 0x05, 0x7c, 0xd0, 0x19, 0x04, 0x41, 0x07, 0x61, 0x79, 0x9a, 0xc7,
	0xfb, 0x7d, 0x37, 0xf4, 0xcd, 0x72, 0x7a, 0x5a, 0xa6, 0xca, 0xd8, 0xdc, 0xb8, 0x9b, 0x98, 0xb3,
	0x08, 0xa3, 0x4c, 0x2e, 0x42, 0x7d, 0x8f, 0xc7, 0xcf, 0x59, 0xd8, 0x75, 0x7c, 0x16, 0x9b, 0x15,
	0xe4, 0x84, 0x0c, 0x5a, 0x67, 0xb1, 0x0c, 0x28, 0x11, 0x3e, 0x0b, 0xcd, 0x2a, 0xbe, 0x69, 0xaa,
	0xc8, 0x8e, 0x10, 0x62, 0x64, 0xce, 0x21, 0x26, 0x45, 0xf2, 0x35, 0x54, 0x64, 0x89, 0xe4, 0x96,
	0x94, 0x8d, 0x76, 0x65, 0x6a, 0x4b, 0xaa, 0x2f, 0x89, 0x43, 0x9e, 0xa4, 0xdd, 0x96, 0x3a, 0x91,
	0x2f, 0x61, 0x96, 0x86, 0x43, 0xb9, 0x1c, 0xa5, 0xf3, 0xe5, 0x93, 0x9c, 0xef, 0x86, 0xc3, 0xcc,
	0x17, 0x5d, 0x88, 0x0d, 0x59, 0x7d, 0x1c, 0x2c, 0xa5, 0x5c, 0x8e, 0x92, 0xe3, 0xea, 0x49, 0x1c,
	0x4a, 0x57, 0x64, 0x5c, 0x8d, 0xa1, 0x02, 0x11, 0x0b, 0x20, 0x8a, 0xd9, 0x90, 0x05, 0xb4, 0x4b,
	0x7d, 0xf3, 0x34, 0xbe, 0xa5, 0x82, 0x90, 0x8f, 0xe1, 0x94, 0x1b, 0x04, 0x7c, 0xcf, 0x09, 0xe9,
	0x9e, 0x93, 0xe3, 0x89, 0x79, 0x06, 0x2d, 0x09, 0x3e, 0xdb, 0xa2, 0x7b, 0x9d, 0xfc, 0xc9, 0xd2,
	0x13, 0x80, 0xe2, 0xad, 0x8f, 0x18, 0xa8, 0xeb, 0xea, 0x40, 0x1d, 0xfe, 0xc8, 0xa8, 0x0d, 0xaf,
	0x4c, 0x9b, 0x1c, 0xd3, 0x3c, 0x1f, 0xef, 0x1a, 0x53, 0x5d, 0x75, 0x7c, 0x06, 0x8b, 0x87, 0x92,
	0x70, 0x04, 0xc1, 0xb5, 0xc9, 0xb0, 0xa6, 0x96, 0xbe, 0xc2, 0xa0, 0xae, 0x80, 0x71, 0x15, 0x9a,
	0x13, 0x9f, 0x45, 0x39, 0xa2, 0x11, 0xf7, 0x9d, 0x01, 0xf3, 0x33, 0xf2, 0x6a, 0xc4, 0xfd, 0x27,
	0xcc, 0x27, 0xff, 0x05, 0x3d, 0x74, 0xfb, 0x34, 0x89, 0x5c, 0xef, 0x20, 0xc8, 0x02, 0x90, 0x0d,
	0x2b, 0x15, 0x1c, 0x32, 0xdd, 0x46, 0x99, 0x7c, 0x03, 0x90, 0x8f, 0xff, 0x41, 0xb3, 0xfd, 0xff,
	0x84, 0x4f, 0x72, 0x91, 0xbb, 0xac, 0xd2, 0x8a, 0x3b, 0x61, 0x70, 0x46, 0x99, 0x2b, 0x77, 0x20,
	0x7a, 0x8e, 0xc7, 0xc3, 0x5d, 0xd6, 0xcd, 0x1a, 0xf1, 0xd3, 0x93, 0x88, 0x37, 0x0f, 0x06, 0x6f,
	0x75, 0x20, 0x7a, 0x6b, 0xe8, 0x96, 0x9e, 0xf0, 0x1f, 0x76, 0xf8, 0x09, 0x79, 0x08, 0x0d, 0xdc,
	0x52, 0x69, 0x9f, 0x25, 0xe6, 0x69, 0x3c, 0xe0, 0xa3, 0x93, 0x0e, 0xb8, 0xcf, 0x13, 0x91, 0xa6,
	0x38, 0x0b, 0xbd, 0xde, 0x2b, 0x10, 0xf2, 0x00, 0xea, 0x59, 0xdf, 0xe3, 0x7e, 0x3f, 0xf3, 0xee,
	0x4c, 0xa4, 0x9e, 0xc5, 0xa6, 0x87, 0x61, 0x0e, 0x90, 0x73, 0x50, 0xcb, 0x96, 0xa8, 0x67, 0x5e,
	0xc4, 0x2e, 0x9e, 0x4b, 0xb7, 0xa8, 0x47, 0x2e, 0x65, 0x91, 0x87, 0x54, 0xc8, 0xbd, 0x60, 0xb6,
	0xf0, 0x31, 0xc6, 0xb2, 0x95, 0x42, 0xb9, 0x77, 0xc4, 0x7c, 0xf3, 0x52, 0xe1, 0xdd, 0x61, 0xbe,
	0xdc, 0xfe, 0x52, 0xc4, 0x3a, 0xb6, 0xd3, 0xed, 0x7f, 0xa0, 0x2f, 0x3d, 0x83, 0x85, 0xa9, 0xea,
	0xfc, 0xfb, 0xc9, 0x90, 0x73, 0xad, 0x36, 0xf8, 0x3d, 0x30, 0x8f, 0x2b, 0xd0, 0xfb, 0x7c, 0xcf,
	0x96, 0x6e, 0x83, 0x31, 0x5d, 0x87, 0xf7, 0x1a, 0xb4, 0xa7, 0xb0, 0x30, 0x95, 0xf7, 0x23, 0xdc,
	0xaf, 0x4e, 0xbe, 0xe3, 0xd9, 0x63, 0xbe, 0xd2, 0xea, 0x90, 0x6d, 0x40, 0x73, 0xe2, 0xd2, 0x78,
	0xfc, 0x8c, 0x5d, 0x00, 0xe8, 0xc6, 0xae, 0x47, 0x1d, 0xc1, 0xfa, 0xd4, 0x84, 0x96, 0xb6, 0x5c,
	0xb6, 0x75, 0x44, 0xb6, 0x59, 0x9f, 0xb6, 0x1f, 0x41, 0x5d, 0xb9, 0x39, 0x4e, 0x4e, 0xa4, 0x76,
	0xdc, 0x44, 0xce, 0x28, 0x13, 0x69, 0x40, 0xd9, 0x0d, 0x82, 0xec, 0x4b, 0x28, 0xc5, 0xf6, 0x23,
	0x80, 0xe2, 0x36, 0x79, 0x7c, 0x60, 0x17, 0x01, 0xb2, 0x0f, 0xa1, 0x33, 0xbc, 0x8e, 0x81, 0x35,
	0xee, 0x97, 0x6c, 0x3d, 0xc3, 0x9e, 0x5e, 0x57, 0xef, 0x34, 0x36, 0xd4, 0x95, 0x2b, 0xe6, 0x87,
	0xe1, 0xfc, 0x0e, 0xc8, 0xe1, 0xeb, 0xe6, 0x87, 0xa1, 0x6e, 0x43, 0x43, 0xbd, 0x7a, 0xca, 0xbc,
	0x65, 0xb7, 0x30, 0xd9, 0x5e, 0x28, 0xb7, 0x6f, 0x81, 0x31, 0x7d, 0xb5, 0x94, 0x76, 0x1e, 0x0f,
	0x12, 0xb4, 0x6b, 0xda, 0x28, 0x4b, 0x2c, 0xe6, 0x7b, 0x09, 0xe6, 0xbc, 0x69, 0xa3, 0x7c, 0xe7,
	0xe6, 0xab, 0x37, 0x56, 0xe9, 0xf5, 0x1b, 0xab, 0xf4, 0xf6, 0x8d, 0xa5, 0xfd, 0x38, 0xb6, 0xb4,
	0xdf, 0xc7, 0x96, 0xf6, 0x72, 0x6c, 0x69, 0xaf, 0xc6, 0x96, 0xf6, 0xe7, 0xd8, 0xd2, 0xfe, 0x1a,
	0x5b, 0xa5, 0xb7, 0x63, 0x4b, 0xfb, 0x65, 0xdf, 0x2a, 0xbd, 0xdc, 0xb7, 0xb4, 0x57, 0xfb, 0x56,
	0xe9, 0xf5, 0xbe, 0x55, 0xda, 0xa9, 0xe2, 0xdd, 0xeb, 0x93, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff,
	0xc6, 0x82, 0x60, 0x3e, 0x74, 0x0e, 0x00, 0x00,
}

func (x NodeCmd_NodeAction) String() string {
	s, ok := NodeCmd_NodeAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ImageCmd_ImageAction) String() string {
	s, ok := ImageCmd_ImageAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x PodCmd_PodAction) String() string {
	s, ok := PodCmd_PodAction_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *NodeCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NodeCmd)
	if !ok {
		that2, ok := that.(NodeCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	return true
}
func (this *ImageCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageCmd)
	if !ok {
		that2, ok := that.(ImageCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	return true
}
func (this *PodCmd) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd)
	if !ok {
		that2, ok := that.(PodCmd)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if that1.Options == nil {
		if this.Options != nil {
			return false
		}
	} else if this.Options == nil {
		return false
	} else if !this.Options.Equal(that1.Options) {
		return false
	}
	return true
}
func (this *PodCmd_CreateOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_CreateOptions)
	if !ok {
		that2, ok := that.(PodCmd_CreateOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CreateOptions.Equal(that1.CreateOptions) {
		return false
	}
	return true
}
func (this *PodCmd_DeleteOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_DeleteOptions)
	if !ok {
		that2, ok := that.(PodCmd_DeleteOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeleteOptions.Equal(that1.DeleteOptions) {
		return false
	}
	return true
}
func (this *PodCmd_ListOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_ListOptions)
	if !ok {
		that2, ok := that.(PodCmd_ListOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ListOptions.Equal(that1.ListOptions) {
		return false
	}
	return true
}
func (this *PodCmd_LogOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_LogOptions)
	if !ok {
		that2, ok := that.(PodCmd_LogOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogOptions.Equal(that1.LogOptions) {
		return false
	}
	return true
}
func (this *PodCmd_ExecOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_ExecOptions)
	if !ok {
		that2, ok := that.(PodCmd_ExecOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ExecOptions.Equal(that1.ExecOptions) {
		return false
	}
	return true
}
func (this *PodCmd_PortForwardOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_PortForwardOptions)
	if !ok {
		that2, ok := that.(PodCmd_PortForwardOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.PortForwardOptions.Equal(that1.PortForwardOptions) {
		return false
	}
	return true
}
func (this *PodCmd_InputOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_InputOptions)
	if !ok {
		that2, ok := that.(PodCmd_InputOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.InputOptions.Equal(that1.InputOptions) {
		return false
	}
	return true
}
func (this *PodCmd_ResizeOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PodCmd_ResizeOptions)
	if !ok {
		that2, ok := that.(PodCmd_ResizeOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ResizeOptions.Equal(that1.ResizeOptions) {
		return false
	}
	return true
}
func (this *NamedData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NamedData)
	if !ok {
		that2, ok := that.(NamedData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if !bytes.Equal(this.Data[i], that1.Data[i]) {
			return false
		}
	}
	return true
}
func (this *ContainerPort) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerPort)
	if !ok {
		that2, ok := that.(ContainerPort)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Protocol != that1.Protocol {
		return false
	}
	if this.HostPort != that1.HostPort {
		return false
	}
	if this.ContainerPort != that1.ContainerPort {
		return false
	}
	if this.HostIp != that1.HostIp {
		return false
	}
	return true
}
func (this *VolumeMount) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VolumeMount)
	if !ok {
		that2, ok := that.(VolumeMount)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MountPath != that1.MountPath {
		return false
	}
	if this.VolumeSubPath != that1.VolumeSubPath {
		return false
	}
	if this.ReadOnly != that1.ReadOnly {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if len(this.Options) != len(that1.Options) {
		return false
	}
	for i := range this.Options {
		if this.Options[i] != that1.Options[i] {
			return false
		}
	}
	return true
}
func (this *ContainerSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ContainerSpec)
	if !ok {
		that2, ok := that.(ContainerSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Image != that1.Image {
		return false
	}
	if this.ImagePullPolicy != that1.ImagePullPolicy {
		return false
	}
	if len(this.Command) != len(that1.Command) {
		return false
	}
	for i := range this.Command {
		if this.Command[i] != that1.Command[i] {
			return false
		}
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if this.Args[i] != that1.Args[i] {
			return false
		}
	}
	if this.WorkingDir != that1.WorkingDir {
		return false
	}
	if this.Stdin != that1.Stdin {
		return false
	}
	if this.Tty != that1.Tty {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if !this.Ports[i].Equal(that1.Ports[i]) {
			return false
		}
	}
	if len(this.Envs) != len(that1.Envs) {
		return false
	}
	for i := range this.Envs {
		if this.Envs[i] != that1.Envs[i] {
			return false
		}
	}
	if len(this.VolumeMounts) != len(that1.VolumeMounts) {
		return false
	}
	for i := range this.VolumeMounts {
		if !this.VolumeMounts[i].Equal(that1.VolumeMounts[i]) {
			return false
		}
	}
	if this.Privileged != that1.Privileged {
		return false
	}
	if this.AllowNewPrivileges != that1.AllowNewPrivileges {
		return false
	}
	return true
}
func (this *CreateOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateOptions)
	if !ok {
		that2, ok := that.(CreateOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Containers) != len(that1.Containers) {
		return false
	}
	for i := range this.Containers {
		if !this.Containers[i].Equal(that1.Containers[i]) {
			return false
		}
	}
	if len(this.ImagePullAuthConfig) != len(that1.ImagePullAuthConfig) {
		return false
	}
	for i := range this.ImagePullAuthConfig {
		if !bytes.Equal(this.ImagePullAuthConfig[i], that1.ImagePullAuthConfig[i]) {
			return false
		}
	}
	if len(this.HostVolumes) != len(that1.HostVolumes) {
		return false
	}
	for i := range this.HostVolumes {
		if this.HostVolumes[i] != that1.HostVolumes[i] {
			return false
		}
	}
	if len(this.VolumeData) != len(that1.VolumeData) {
		return false
	}
	for i := range this.VolumeData {
		if !this.VolumeData[i].Equal(that1.VolumeData[i]) {
			return false
		}
	}
	if this.HostIpc != that1.HostIpc {
		return false
	}
	if this.HostNetwork != that1.HostNetwork {
		return false
	}
	if this.HostPid != that1.HostPid {
		return false
	}
	if this.Hostname != that1.Hostname {
		return false
	}
	return true
}
func (this *DeleteOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeleteOptions)
	if !ok {
		that2, ok := that.(DeleteOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if this.GraceTime != that1.GraceTime {
		return false
	}
	return true
}
func (this *ListOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListOptions)
	if !ok {
		that2, ok := that.(ListOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Namespace != that1.Namespace {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.All != that1.All {
		return false
	}
	return true
}
func (this *LogOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogOptions)
	if !ok {
		that2, ok := that.(LogOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if that1.Options == nil {
		if this.Options != nil {
			return false
		}
	} else if this.Options == nil {
		return false
	} else if !this.Options.Equal(that1.Options) {
		return false
	}
	return true
}
func (this *LogOptions_OptionsV1) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogOptions_OptionsV1)
	if !ok {
		that2, ok := that.(LogOptions_OptionsV1)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.OptionsV1, that1.OptionsV1) {
		return false
	}
	return true
}
func (this *ExecOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecOptions)
	if !ok {
		that2, ok := that.(ExecOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if that1.Options == nil {
		if this.Options != nil {
			return false
		}
	} else if this.Options == nil {
		return false
	} else if !this.Options.Equal(that1.Options) {
		return false
	}
	return true
}
func (this *ExecOptions_OptionsV1) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExecOptions_OptionsV1)
	if !ok {
		that2, ok := that.(ExecOptions_OptionsV1)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.OptionsV1, that1.OptionsV1) {
		return false
	}
	return true
}
func (this *PortForwardOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortForwardOptions)
	if !ok {
		that2, ok := that.(PortForwardOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PodUid != that1.PodUid {
		return false
	}
	if that1.Options == nil {
		if this.Options != nil {
			return false
		}
	} else if this.Options == nil {
		return false
	} else if !this.Options.Equal(that1.Options) {
		return false
	}
	return true
}
func (this *PortForwardOptions_OptionsV1) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortForwardOptions_OptionsV1)
	if !ok {
		that2, ok := that.(PortForwardOptions_OptionsV1)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.OptionsV1, that1.OptionsV1) {
		return false
	}
	return true
}
func (this *InputOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InputOptions)
	if !ok {
		that2, ok := that.(InputOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (this *TtyResizeOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TtyResizeOptions)
	if !ok {
		that2, ok := that.(TtyResizeOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Cols != that1.Cols {
		return false
	}
	if this.Rows != that1.Rows {
		return false
	}
	return true
}
func (this *NodeCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&connectivity.NodeCmd{")
	s = append(s, "action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImageCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&connectivity.ImageCmd{")
	s = append(s, "action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodCmd) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&connectivity.PodCmd{")
	s = append(s, "action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PodCmd_CreateOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_CreateOptions{` +
		`CreateOptions:` + fmt.Sprintf("%#v", this.CreateOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_DeleteOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_DeleteOptions{` +
		`DeleteOptions:` + fmt.Sprintf("%#v", this.DeleteOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_ListOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_ListOptions{` +
		`ListOptions:` + fmt.Sprintf("%#v", this.ListOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_LogOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_LogOptions{` +
		`LogOptions:` + fmt.Sprintf("%#v", this.LogOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_ExecOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_ExecOptions{` +
		`ExecOptions:` + fmt.Sprintf("%#v", this.ExecOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_PortForwardOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_PortForwardOptions{` +
		`PortForwardOptions:` + fmt.Sprintf("%#v", this.PortForwardOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_InputOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_InputOptions{` +
		`InputOptions:` + fmt.Sprintf("%#v", this.InputOptions) + `}`}, ", ")
	return s
}
func (this *PodCmd_ResizeOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PodCmd_ResizeOptions{` +
		`ResizeOptions:` + fmt.Sprintf("%#v", this.ResizeOptions) + `}`}, ", ")
	return s
}
func (this *NamedData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&connectivity.NamedData{")
	keysForData := make([]string, 0, len(this.Data))
	for k, _ := range this.Data {
		keysForData = append(keysForData, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForData)
	mapStringForData := "map[string][]byte{"
	for _, k := range keysForData {
		mapStringForData += fmt.Sprintf("%#v: %#v,", k, this.Data[k])
	}
	mapStringForData += "}"
	if this.Data != nil {
		s = append(s, "Data: "+mapStringForData+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerPort) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&connectivity.ContainerPort{")
	s = append(s, "Protocol: "+fmt.Sprintf("%#v", this.Protocol)+",\n")
	s = append(s, "HostPort: "+fmt.Sprintf("%#v", this.HostPort)+",\n")
	s = append(s, "ContainerPort: "+fmt.Sprintf("%#v", this.ContainerPort)+",\n")
	s = append(s, "HostIp: "+fmt.Sprintf("%#v", this.HostIp)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VolumeMount) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&connectivity.VolumeMount{")
	s = append(s, "MountPath: "+fmt.Sprintf("%#v", this.MountPath)+",\n")
	s = append(s, "VolumeSubPath: "+fmt.Sprintf("%#v", this.VolumeSubPath)+",\n")
	s = append(s, "ReadOnly: "+fmt.Sprintf("%#v", this.ReadOnly)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ContainerSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&connectivity.ContainerSpec{")
	s = append(s, "Image: "+fmt.Sprintf("%#v", this.Image)+",\n")
	s = append(s, "ImagePullPolicy: "+fmt.Sprintf("%#v", this.ImagePullPolicy)+",\n")
	s = append(s, "Command: "+fmt.Sprintf("%#v", this.Command)+",\n")
	s = append(s, "Args: "+fmt.Sprintf("%#v", this.Args)+",\n")
	s = append(s, "WorkingDir: "+fmt.Sprintf("%#v", this.WorkingDir)+",\n")
	s = append(s, "Stdin: "+fmt.Sprintf("%#v", this.Stdin)+",\n")
	s = append(s, "Tty: "+fmt.Sprintf("%#v", this.Tty)+",\n")
	keysForPorts := make([]string, 0, len(this.Ports))
	for k, _ := range this.Ports {
		keysForPorts = append(keysForPorts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPorts)
	mapStringForPorts := "map[string]*ContainerPort{"
	for _, k := range keysForPorts {
		mapStringForPorts += fmt.Sprintf("%#v: %#v,", k, this.Ports[k])
	}
	mapStringForPorts += "}"
	if this.Ports != nil {
		s = append(s, "Ports: "+mapStringForPorts+",\n")
	}
	keysForEnvs := make([]string, 0, len(this.Envs))
	for k, _ := range this.Envs {
		keysForEnvs = append(keysForEnvs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEnvs)
	mapStringForEnvs := "map[string]string{"
	for _, k := range keysForEnvs {
		mapStringForEnvs += fmt.Sprintf("%#v: %#v,", k, this.Envs[k])
	}
	mapStringForEnvs += "}"
	if this.Envs != nil {
		s = append(s, "Envs: "+mapStringForEnvs+",\n")
	}
	keysForVolumeMounts := make([]string, 0, len(this.VolumeMounts))
	for k, _ := range this.VolumeMounts {
		keysForVolumeMounts = append(keysForVolumeMounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVolumeMounts)
	mapStringForVolumeMounts := "map[string]*VolumeMount{"
	for _, k := range keysForVolumeMounts {
		mapStringForVolumeMounts += fmt.Sprintf("%#v: %#v,", k, this.VolumeMounts[k])
	}
	mapStringForVolumeMounts += "}"
	if this.VolumeMounts != nil {
		s = append(s, "VolumeMounts: "+mapStringForVolumeMounts+",\n")
	}
	s = append(s, "Privileged: "+fmt.Sprintf("%#v", this.Privileged)+",\n")
	s = append(s, "AllowNewPrivileges: "+fmt.Sprintf("%#v", this.AllowNewPrivileges)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&connectivity.CreateOptions{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	keysForContainers := make([]string, 0, len(this.Containers))
	for k, _ := range this.Containers {
		keysForContainers = append(keysForContainers, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForContainers)
	mapStringForContainers := "map[string]*ContainerSpec{"
	for _, k := range keysForContainers {
		mapStringForContainers += fmt.Sprintf("%#v: %#v,", k, this.Containers[k])
	}
	mapStringForContainers += "}"
	if this.Containers != nil {
		s = append(s, "Containers: "+mapStringForContainers+",\n")
	}
	keysForImagePullAuthConfig := make([]string, 0, len(this.ImagePullAuthConfig))
	for k, _ := range this.ImagePullAuthConfig {
		keysForImagePullAuthConfig = append(keysForImagePullAuthConfig, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForImagePullAuthConfig)
	mapStringForImagePullAuthConfig := "map[string][]byte{"
	for _, k := range keysForImagePullAuthConfig {
		mapStringForImagePullAuthConfig += fmt.Sprintf("%#v: %#v,", k, this.ImagePullAuthConfig[k])
	}
	mapStringForImagePullAuthConfig += "}"
	if this.ImagePullAuthConfig != nil {
		s = append(s, "ImagePullAuthConfig: "+mapStringForImagePullAuthConfig+",\n")
	}
	keysForHostVolumes := make([]string, 0, len(this.HostVolumes))
	for k, _ := range this.HostVolumes {
		keysForHostVolumes = append(keysForHostVolumes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHostVolumes)
	mapStringForHostVolumes := "map[string]string{"
	for _, k := range keysForHostVolumes {
		mapStringForHostVolumes += fmt.Sprintf("%#v: %#v,", k, this.HostVolumes[k])
	}
	mapStringForHostVolumes += "}"
	if this.HostVolumes != nil {
		s = append(s, "HostVolumes: "+mapStringForHostVolumes+",\n")
	}
	keysForVolumeData := make([]string, 0, len(this.VolumeData))
	for k, _ := range this.VolumeData {
		keysForVolumeData = append(keysForVolumeData, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVolumeData)
	mapStringForVolumeData := "map[string]*NamedData{"
	for _, k := range keysForVolumeData {
		mapStringForVolumeData += fmt.Sprintf("%#v: %#v,", k, this.VolumeData[k])
	}
	mapStringForVolumeData += "}"
	if this.VolumeData != nil {
		s = append(s, "VolumeData: "+mapStringForVolumeData+",\n")
	}
	s = append(s, "HostIpc: "+fmt.Sprintf("%#v", this.HostIpc)+",\n")
	s = append(s, "HostNetwork: "+fmt.Sprintf("%#v", this.HostNetwork)+",\n")
	s = append(s, "HostPid: "+fmt.Sprintf("%#v", this.HostPid)+",\n")
	s = append(s, "Hostname: "+fmt.Sprintf("%#v", this.Hostname)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DeleteOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&connectivity.DeleteOptions{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	s = append(s, "GraceTime: "+fmt.Sprintf("%#v", this.GraceTime)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&connectivity.ListOptions{")
	s = append(s, "Namespace: "+fmt.Sprintf("%#v", this.Namespace)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "All: "+fmt.Sprintf("%#v", this.All)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LogOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&connectivity.LogOptions{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LogOptions_OptionsV1) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.LogOptions_OptionsV1{` +
		`OptionsV1:` + fmt.Sprintf("%#v", this.OptionsV1) + `}`}, ", ")
	return s
}
func (this *ExecOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&connectivity.ExecOptions{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ExecOptions_OptionsV1) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.ExecOptions_OptionsV1{` +
		`OptionsV1:` + fmt.Sprintf("%#v", this.OptionsV1) + `}`}, ", ")
	return s
}
func (this *PortForwardOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&connectivity.PortForwardOptions{")
	s = append(s, "PodUid: "+fmt.Sprintf("%#v", this.PodUid)+",\n")
	if this.Options != nil {
		s = append(s, "Options: "+fmt.Sprintf("%#v", this.Options)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PortForwardOptions_OptionsV1) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&connectivity.PortForwardOptions_OptionsV1{` +
		`OptionsV1:` + fmt.Sprintf("%#v", this.OptionsV1) + `}`}, ", ")
	return s
}
func (this *InputOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&connectivity.InputOptions{")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TtyResizeOptions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&connectivity.TtyResizeOptions{")
	s = append(s, "Cols: "+fmt.Sprintf("%#v", this.Cols)+",\n")
	s = append(s, "Rows: "+fmt.Sprintf("%#v", this.Rows)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringCmdDetail(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *NodeCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCmd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.Action))
	}
	return i, nil
}

func (m *ImageCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageCmd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.Action))
	}
	return i, nil
}

func (m *PodCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PodCmd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.Action))
	}
	if m.Options != nil {
		nn1, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *PodCmd_CreateOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CreateOptions != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.CreateOptions.Size()))
		n2, err := m.CreateOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *PodCmd_DeleteOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DeleteOptions != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.DeleteOptions.Size()))
		n3, err := m.DeleteOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *PodCmd_ListOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ListOptions != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.ListOptions.Size()))
		n4, err := m.ListOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *PodCmd_LogOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LogOptions != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.LogOptions.Size()))
		n5, err := m.LogOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *PodCmd_ExecOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ExecOptions != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.ExecOptions.Size()))
		n6, err := m.ExecOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *PodCmd_PortForwardOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PortForwardOptions != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.PortForwardOptions.Size()))
		n7, err := m.PortForwardOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *PodCmd_InputOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.InputOptions != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.InputOptions.Size()))
		n8, err := m.InputOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *PodCmd_ResizeOptions) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.ResizeOptions != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.ResizeOptions.Size()))
		n9, err := m.ResizeOptions.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *NamedData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamedData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, _ := range m.Data {
			dAtA[i] = 0xa
			i++
			v := m.Data[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovCmdDetail(uint64(len(v)))
			}
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + byteSize
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCmdDetail(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	return i, nil
}

func (m *ContainerPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerPort) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Protocol) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Protocol)))
		i += copy(dAtA[i:], m.Protocol)
	}
	if m.HostPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.HostPort))
	}
	if m.ContainerPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.ContainerPort))
	}
	if len(m.HostIp) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.HostIp)))
		i += copy(dAtA[i:], m.HostIp)
	}
	return i, nil
}

func (m *VolumeMount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VolumeMount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MountPath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.MountPath)))
		i += copy(dAtA[i:], m.MountPath)
	}
	if len(m.VolumeSubPath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.VolumeSubPath)))
		i += copy(dAtA[i:], m.VolumeSubPath)
	}
	if m.ReadOnly {
		dAtA[i] = 0x18
		i++
		if m.ReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Options) > 0 {
		for _, s := range m.Options {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ContainerSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Image) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.ImagePullPolicy) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.ImagePullPolicy)))
		i += copy(dAtA[i:], m.ImagePullPolicy)
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.WorkingDir) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.WorkingDir)))
		i += copy(dAtA[i:], m.WorkingDir)
	}
	if m.Stdin {
		dAtA[i] = 0x30
		i++
		if m.Stdin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Tty {
		dAtA[i] = 0x38
		i++
		if m.Tty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Ports) > 0 {
		for k, _ := range m.Ports {
			dAtA[i] = 0x5a
			i++
			v := m.Ports[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCmdDetail(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + msgSize
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCmdDetail(dAtA, i, uint64(v.Size()))
				n10, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n10
			}
		}
	}
	if len(m.Envs) > 0 {
		for k, _ := range m.Envs {
			dAtA[i] = 0x62
			i++
			v := m.Envs[k]
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + 1 + len(v) + sovCmdDetail(uint64(len(v)))
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.VolumeMounts) > 0 {
		for k, _ := range m.VolumeMounts {
			dAtA[i] = 0x6a
			i++
			v := m.VolumeMounts[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCmdDetail(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + msgSize
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCmdDetail(dAtA, i, uint64(v.Size()))
				n11, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n11
			}
		}
	}
	if m.Privileged {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		if m.Privileged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AllowNewPrivileges {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.AllowNewPrivileges {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CreateOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PodUid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.PodUid)))
		i += copy(dAtA[i:], m.PodUid)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Containers) > 0 {
		for k, _ := range m.Containers {
			dAtA[i] = 0x5a
			i++
			v := m.Containers[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCmdDetail(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + msgSize
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCmdDetail(dAtA, i, uint64(v.Size()))
				n12, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n12
			}
		}
	}
	if len(m.ImagePullAuthConfig) > 0 {
		for k, _ := range m.ImagePullAuthConfig {
			dAtA[i] = 0x62
			i++
			v := m.ImagePullAuthConfig[k]
			byteSize := 0
			if len(v) > 0 {
				byteSize = 1 + len(v) + sovCmdDetail(uint64(len(v)))
			}
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + byteSize
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if len(v) > 0 {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCmdDetail(dAtA, i, uint64(len(v)))
				i += copy(dAtA[i:], v)
			}
		}
	}
	if len(m.HostVolumes) > 0 {
		for k, _ := range m.HostVolumes {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			v := m.HostVolumes[k]
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + 1 + len(v) + sovCmdDetail(uint64(len(v)))
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.VolumeData) > 0 {
		for k, _ := range m.VolumeData {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.VolumeData[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCmdDetail(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + msgSize
			i = encodeVarintCmdDetail(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCmdDetail(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCmdDetail(dAtA, i, uint64(v.Size()))
				n13, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n13
			}
		}
	}
	if m.HostIpc {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		if m.HostIpc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HostNetwork {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		if m.HostNetwork {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HostPid {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		if m.HostPid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	return i, nil
}

func (m *DeleteOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PodUid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.PodUid)))
		i += copy(dAtA[i:], m.PodUid)
	}
	if m.GraceTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.GraceTime))
	}
	return i, nil
}

func (m *ListOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.All {
		dAtA[i] = 0x18
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LogOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PodUid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.PodUid)))
		i += copy(dAtA[i:], m.PodUid)
	}
	if m.Options != nil {
		nn14, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn14
	}
	return i, nil
}

func (m *LogOptions_OptionsV1) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OptionsV1 != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.OptionsV1)))
		i += copy(dAtA[i:], m.OptionsV1)
	}
	return i, nil
}
func (m *ExecOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PodUid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.PodUid)))
		i += copy(dAtA[i:], m.PodUid)
	}
	if m.Options != nil {
		nn15, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn15
	}
	return i, nil
}

func (m *ExecOptions_OptionsV1) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OptionsV1 != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.OptionsV1)))
		i += copy(dAtA[i:], m.OptionsV1)
	}
	return i, nil
}
func (m *PortForwardOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortForwardOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PodUid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.PodUid)))
		i += copy(dAtA[i:], m.PodUid)
	}
	if m.Options != nil {
		nn16, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	return i, nil
}

func (m *PortForwardOptions_OptionsV1) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OptionsV1 != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.OptionsV1)))
		i += copy(dAtA[i:], m.OptionsV1)
	}
	return i, nil
}
func (m *InputOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *TtyResizeOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TtyResizeOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cols != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.Cols))
	}
	if m.Rows != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCmdDetail(dAtA, i, uint64(m.Rows))
	}
	return i, nil
}

func encodeVarintCmdDetail(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *NodeCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovCmdDetail(uint64(m.Action))
	}
	return n
}

func (m *ImageCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovCmdDetail(uint64(m.Action))
	}
	return n
}

func (m *PodCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovCmdDetail(uint64(m.Action))
	}
	if m.Options != nil {
		n += m.Options.Size()
	}
	return n
}

func (m *PodCmd_CreateOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateOptions != nil {
		l = m.CreateOptions.Size()
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *PodCmd_DeleteOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteOptions != nil {
		l = m.DeleteOptions.Size()
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *PodCmd_ListOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ListOptions != nil {
		l = m.ListOptions.Size()
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *PodCmd_LogOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogOptions != nil {
		l = m.LogOptions.Size()
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *PodCmd_ExecOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExecOptions != nil {
		l = m.ExecOptions.Size()
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *PodCmd_PortForwardOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortForwardOptions != nil {
		l = m.PortForwardOptions.Size()
		n += 2 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *PodCmd_InputOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InputOptions != nil {
		l = m.InputOptions.Size()
		n += 2 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *PodCmd_ResizeOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResizeOptions != nil {
		l = m.ResizeOptions.Size()
		n += 2 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *NamedData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovCmdDetail(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ContainerPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.HostPort != 0 {
		n += 1 + sovCmdDetail(uint64(m.HostPort))
	}
	if m.ContainerPort != 0 {
		n += 1 + sovCmdDetail(uint64(m.ContainerPort))
	}
	l = len(m.HostIp)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}

func (m *VolumeMount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MountPath)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.VolumeSubPath)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.ReadOnly {
		n += 2
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if len(m.Options) > 0 {
		for _, s := range m.Options {
			l = len(s)
			n += 1 + l + sovCmdDetail(uint64(l))
		}
	}
	return n
}

func (m *ContainerSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.ImagePullPolicy)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if len(m.Command) > 0 {
		for _, s := range m.Command {
			l = len(s)
			n += 1 + l + sovCmdDetail(uint64(l))
		}
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovCmdDetail(uint64(l))
		}
	}
	l = len(m.WorkingDir)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.Stdin {
		n += 2
	}
	if m.Tty {
		n += 2
	}
	if len(m.Ports) > 0 {
		for k, v := range m.Ports {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdDetail(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	if len(m.Envs) > 0 {
		for k, v := range m.Envs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + 1 + len(v) + sovCmdDetail(uint64(len(v)))
			n += mapEntrySize + 1 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	if len(m.VolumeMounts) > 0 {
		for k, v := range m.VolumeMounts {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdDetail(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	if m.Privileged {
		n += 3
	}
	if m.AllowNewPrivileges {
		n += 3
	}
	return n
}

func (m *CreateOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if len(m.Containers) > 0 {
		for k, v := range m.Containers {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdDetail(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	if len(m.ImagePullAuthConfig) > 0 {
		for k, v := range m.ImagePullAuthConfig {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovCmdDetail(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	if len(m.HostVolumes) > 0 {
		for k, v := range m.HostVolumes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + 1 + len(v) + sovCmdDetail(uint64(len(v)))
			n += mapEntrySize + 2 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	if len(m.VolumeData) > 0 {
		for k, v := range m.VolumeData {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCmdDetail(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCmdDetail(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovCmdDetail(uint64(mapEntrySize))
		}
	}
	if m.HostIpc {
		n += 3
	}
	if m.HostNetwork {
		n += 3
	}
	if m.HostPid {
		n += 3
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 2 + l + sovCmdDetail(uint64(l))
	}
	return n
}

func (m *DeleteOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.GraceTime != 0 {
		n += 1 + sovCmdDetail(uint64(m.GraceTime))
	}
	return n
}

func (m *ListOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.All {
		n += 2
	}
	return n
}

func (m *LogOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.Options != nil {
		n += m.Options.Size()
	}
	return n
}

func (m *LogOptions_OptionsV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionsV1 != nil {
		l = len(m.OptionsV1)
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *ExecOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.Options != nil {
		n += m.Options.Size()
	}
	return n
}

func (m *ExecOptions_OptionsV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionsV1 != nil {
		l = len(m.OptionsV1)
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *PortForwardOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PodUid)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	if m.Options != nil {
		n += m.Options.Size()
	}
	return n
}

func (m *PortForwardOptions_OptionsV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OptionsV1 != nil {
		l = len(m.OptionsV1)
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}
func (m *InputOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCmdDetail(uint64(l))
	}
	return n
}

func (m *TtyResizeOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cols != 0 {
		n += 1 + sovCmdDetail(uint64(m.Cols))
	}
	if m.Rows != 0 {
		n += 1 + sovCmdDetail(uint64(m.Rows))
	}
	return n
}

func sovCmdDetail(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCmdDetail(x uint64) (n int) {
	return sovCmdDetail(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *NodeCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NodeCmd{`,
		`action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageCmd{`,
		`action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd{`,
		`action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`Options:` + fmt.Sprintf("%v", this.Options) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_CreateOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_CreateOptions{`,
		`CreateOptions:` + strings.Replace(fmt.Sprintf("%v", this.CreateOptions), "CreateOptions", "CreateOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_DeleteOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_DeleteOptions{`,
		`DeleteOptions:` + strings.Replace(fmt.Sprintf("%v", this.DeleteOptions), "DeleteOptions", "DeleteOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_ListOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_ListOptions{`,
		`ListOptions:` + strings.Replace(fmt.Sprintf("%v", this.ListOptions), "ListOptions", "ListOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_LogOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_LogOptions{`,
		`LogOptions:` + strings.Replace(fmt.Sprintf("%v", this.LogOptions), "LogOptions", "LogOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_ExecOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_ExecOptions{`,
		`ExecOptions:` + strings.Replace(fmt.Sprintf("%v", this.ExecOptions), "ExecOptions", "ExecOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_PortForwardOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_PortForwardOptions{`,
		`PortForwardOptions:` + strings.Replace(fmt.Sprintf("%v", this.PortForwardOptions), "PortForwardOptions", "PortForwardOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_InputOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_InputOptions{`,
		`InputOptions:` + strings.Replace(fmt.Sprintf("%v", this.InputOptions), "InputOptions", "InputOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PodCmd_ResizeOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PodCmd_ResizeOptions{`,
		`ResizeOptions:` + strings.Replace(fmt.Sprintf("%v", this.ResizeOptions), "TtyResizeOptions", "TtyResizeOptions", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NamedData) String() string {
	if this == nil {
		return "nil"
	}
	keysForData := make([]string, 0, len(this.Data))
	for k, _ := range this.Data {
		keysForData = append(keysForData, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForData)
	mapStringForData := "map[string][]byte{"
	for _, k := range keysForData {
		mapStringForData += fmt.Sprintf("%v: %v,", k, this.Data[k])
	}
	mapStringForData += "}"
	s := strings.Join([]string{`&NamedData{`,
		`Data:` + mapStringForData + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerPort) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ContainerPort{`,
		`Protocol:` + fmt.Sprintf("%v", this.Protocol) + `,`,
		`HostPort:` + fmt.Sprintf("%v", this.HostPort) + `,`,
		`ContainerPort:` + fmt.Sprintf("%v", this.ContainerPort) + `,`,
		`HostIp:` + fmt.Sprintf("%v", this.HostIp) + `,`,
		`}`,
	}, "")
	return s
}
func (this *VolumeMount) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&VolumeMount{`,
		`MountPath:` + fmt.Sprintf("%v", this.MountPath) + `,`,
		`VolumeSubPath:` + fmt.Sprintf("%v", this.VolumeSubPath) + `,`,
		`ReadOnly:` + fmt.Sprintf("%v", this.ReadOnly) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Options:` + fmt.Sprintf("%v", this.Options) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ContainerSpec) String() string {
	if this == nil {
		return "nil"
	}
	keysForPorts := make([]string, 0, len(this.Ports))
	for k, _ := range this.Ports {
		keysForPorts = append(keysForPorts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForPorts)
	mapStringForPorts := "map[string]*ContainerPort{"
	for _, k := range keysForPorts {
		mapStringForPorts += fmt.Sprintf("%v: %v,", k, this.Ports[k])
	}
	mapStringForPorts += "}"
	keysForEnvs := make([]string, 0, len(this.Envs))
	for k, _ := range this.Envs {
		keysForEnvs = append(keysForEnvs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEnvs)
	mapStringForEnvs := "map[string]string{"
	for _, k := range keysForEnvs {
		mapStringForEnvs += fmt.Sprintf("%v: %v,", k, this.Envs[k])
	}
	mapStringForEnvs += "}"
	keysForVolumeMounts := make([]string, 0, len(this.VolumeMounts))
	for k, _ := range this.VolumeMounts {
		keysForVolumeMounts = append(keysForVolumeMounts, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVolumeMounts)
	mapStringForVolumeMounts := "map[string]*VolumeMount{"
	for _, k := range keysForVolumeMounts {
		mapStringForVolumeMounts += fmt.Sprintf("%v: %v,", k, this.VolumeMounts[k])
	}
	mapStringForVolumeMounts += "}"
	s := strings.Join([]string{`&ContainerSpec{`,
		`Image:` + fmt.Sprintf("%v", this.Image) + `,`,
		`ImagePullPolicy:` + fmt.Sprintf("%v", this.ImagePullPolicy) + `,`,
		`Command:` + fmt.Sprintf("%v", this.Command) + `,`,
		`Args:` + fmt.Sprintf("%v", this.Args) + `,`,
		`WorkingDir:` + fmt.Sprintf("%v", this.WorkingDir) + `,`,
		`Stdin:` + fmt.Sprintf("%v", this.Stdin) + `,`,
		`Tty:` + fmt.Sprintf("%v", this.Tty) + `,`,
		`Ports:` + mapStringForPorts + `,`,
		`Envs:` + mapStringForEnvs + `,`,
		`VolumeMounts:` + mapStringForVolumeMounts + `,`,
		`Privileged:` + fmt.Sprintf("%v", this.Privileged) + `,`,
		`AllowNewPrivileges:` + fmt.Sprintf("%v", this.AllowNewPrivileges) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateOptions) String() string {
	if this == nil {
		return "nil"
	}
	keysForContainers := make([]string, 0, len(this.Containers))
	for k, _ := range this.Containers {
		keysForContainers = append(keysForContainers, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForContainers)
	mapStringForContainers := "map[string]*ContainerSpec{"
	for _, k := range keysForContainers {
		mapStringForContainers += fmt.Sprintf("%v: %v,", k, this.Containers[k])
	}
	mapStringForContainers += "}"
	keysForImagePullAuthConfig := make([]string, 0, len(this.ImagePullAuthConfig))
	for k, _ := range this.ImagePullAuthConfig {
		keysForImagePullAuthConfig = append(keysForImagePullAuthConfig, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForImagePullAuthConfig)
	mapStringForImagePullAuthConfig := "map[string][]byte{"
	for _, k := range keysForImagePullAuthConfig {
		mapStringForImagePullAuthConfig += fmt.Sprintf("%v: %v,", k, this.ImagePullAuthConfig[k])
	}
	mapStringForImagePullAuthConfig += "}"
	keysForHostVolumes := make([]string, 0, len(this.HostVolumes))
	for k, _ := range this.HostVolumes {
		keysForHostVolumes = append(keysForHostVolumes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForHostVolumes)
	mapStringForHostVolumes := "map[string]string{"
	for _, k := range keysForHostVolumes {
		mapStringForHostVolumes += fmt.Sprintf("%v: %v,", k, this.HostVolumes[k])
	}
	mapStringForHostVolumes += "}"
	keysForVolumeData := make([]string, 0, len(this.VolumeData))
	for k, _ := range this.VolumeData {
		keysForVolumeData = append(keysForVolumeData, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForVolumeData)
	mapStringForVolumeData := "map[string]*NamedData{"
	for _, k := range keysForVolumeData {
		mapStringForVolumeData += fmt.Sprintf("%v: %v,", k, this.VolumeData[k])
	}
	mapStringForVolumeData += "}"
	s := strings.Join([]string{`&CreateOptions{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Containers:` + mapStringForContainers + `,`,
		`ImagePullAuthConfig:` + mapStringForImagePullAuthConfig + `,`,
		`HostVolumes:` + mapStringForHostVolumes + `,`,
		`VolumeData:` + mapStringForVolumeData + `,`,
		`HostIpc:` + fmt.Sprintf("%v", this.HostIpc) + `,`,
		`HostNetwork:` + fmt.Sprintf("%v", this.HostNetwork) + `,`,
		`HostPid:` + fmt.Sprintf("%v", this.HostPid) + `,`,
		`Hostname:` + fmt.Sprintf("%v", this.Hostname) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DeleteOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DeleteOptions{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`GraceTime:` + fmt.Sprintf("%v", this.GraceTime) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListOptions{`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`All:` + fmt.Sprintf("%v", this.All) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LogOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LogOptions{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Options:` + fmt.Sprintf("%v", this.Options) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LogOptions_OptionsV1) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LogOptions_OptionsV1{`,
		`OptionsV1:` + fmt.Sprintf("%v", this.OptionsV1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExecOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExecOptions{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Options:` + fmt.Sprintf("%v", this.Options) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ExecOptions_OptionsV1) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ExecOptions_OptionsV1{`,
		`OptionsV1:` + fmt.Sprintf("%v", this.OptionsV1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortForwardOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortForwardOptions{`,
		`PodUid:` + fmt.Sprintf("%v", this.PodUid) + `,`,
		`Options:` + fmt.Sprintf("%v", this.Options) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortForwardOptions_OptionsV1) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortForwardOptions_OptionsV1{`,
		`OptionsV1:` + fmt.Sprintf("%v", this.OptionsV1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *InputOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&InputOptions{`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TtyResizeOptions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TtyResizeOptions{`,
		`Cols:` + fmt.Sprintf("%v", this.Cols) + `,`,
		`Rows:` + fmt.Sprintf("%v", this.Rows) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringCmdDetail(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *NodeCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= NodeCmd_NodeAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= ImageCmd_ImageAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= PodCmd_PodAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CreateOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_CreateOptions{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_DeleteOptions{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ListOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_ListOptions{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_LogOptions{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ExecOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_ExecOptions{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortForwardOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PortForwardOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_PortForwardOptions{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InputOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_InputOptions{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResizeOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TtyResizeOptions{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Options = &PodCmd_ResizeOptions{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamedData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamedData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamedData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPort", wireType)
			}
			m.HostPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HostPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerPort", wireType)
			}
			m.ContainerPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VolumeMount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VolumeMount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VolumeMount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeSubPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeSubPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Options = append(m.Options, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePullPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = append(m.Command, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkingDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stdin = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tty = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ports == nil {
				m.Ports = make(map[string]*ContainerPort)
			}
			var mapkey string
			var mapvalue *ContainerPort
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ContainerPort{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Ports[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Envs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Envs == nil {
				m.Envs = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Envs[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeMounts == nil {
				m.VolumeMounts = make(map[string]*VolumeMount)
			}
			var mapkey string
			var mapvalue *VolumeMount
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &VolumeMount{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VolumeMounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Privileged = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowNewPrivileges", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowNewPrivileges = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Containers == nil {
				m.Containers = make(map[string]*ContainerSpec)
			}
			var mapkey string
			var mapvalue *ContainerSpec
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ContainerSpec{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Containers[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullAuthConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImagePullAuthConfig == nil {
				m.ImagePullAuthConfig = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ImagePullAuthConfig[mapkey] = mapvalue
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostVolumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostVolumes == nil {
				m.HostVolumes = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HostVolumes[mapkey] = mapvalue
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VolumeData == nil {
				m.VolumeData = make(map[string]*NamedData)
			}
			var mapkey string
			var mapvalue *NamedData
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCmdDetail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCmdDetail
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NamedData{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCmdDetail(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCmdDetail
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.VolumeData[mapkey] = mapvalue
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostIpc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostIpc = bool(v != 0)
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostNetwork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostNetwork = bool(v != 0)
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostPid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HostPid = bool(v != 0)
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GraceTime", wireType)
			}
			m.GraceTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GraceTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionsV1", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Options = &LogOptions_OptionsV1{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionsV1", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Options = &ExecOptions_OptionsV1{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortForwardOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortForwardOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortForwardOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptionsV1", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Options = &PortForwardOptions_OptionsV1{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCmdDetail
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TtyResizeOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TtyResizeOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TtyResizeOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			m.Rows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rows |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCmdDetail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCmdDetail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCmdDetail(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCmdDetail
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCmdDetail
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCmdDetail
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCmdDetail
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCmdDetail
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCmdDetail(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCmdDetail
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCmdDetail = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCmdDetail   = fmt.Errorf("proto: integer overflow")
)
